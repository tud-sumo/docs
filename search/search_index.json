{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the TUD-SUMO Wiki!","text":"<p>This is the documentation for the TUD-SUMO package, a research-oriented wrapper for SUMO<sup>[1]</sup>, developed for the DAIMoND lab at the Technische Universiteit Delft (TUD), the Netherlands. </p> <p>The main goal of TUD-SUMO is to act as a simplified framework for microscopic traffic simulation that allows researchers and students to focus on the important aspects of their projects; their own work, instead of simulation code. TUD-SUMO provides an easy and standardised way to simulate a wide range of scenarios whilst facilitating complex interactions. Resulting data can then be saved, summarised and visualised with minimal code.</p> <p>More information on \"Simulation of Urban MObility\" (SUMO) can be found in the SUMO documentation, here: sumo.dlr.de/docs/</p> <p>The main features of TUD-SUMO include:</p> <ul> <li>Automatic and standardised data collection.</li> <li>Simplified interface to interact with and control the simulation in complex ways.</li> <li>Traffic signal control logic.</li> <li>Extendable controllers already implemented (ramp metering, route guidance and variable speed limits).</li> <li>An event system with dynamic or scheduled incidents.</li> <li>Plotting functions for a wide range of applications.</li> <li>Videos for recording the network or specific vehicles during the simulation.</li> <li>And more in the future! ...</li> </ul> <p></p>"},{"location":"#links","title":"Links","text":"<ol> <li>Simulation of Urban MObility (SUMO) documentation: sumo.dlr.de/docs</li> <li>TUD-SUMO source code (GitHub): DAIMoNDLab/tud-sumo</li> <li>TUD-SUMO PyPI distribution: project/tud-sumo</li> <li>TUD-SUMO example (GitHub): DAIMoNDLab/tud-sumo-examples</li> </ol>"},{"location":"#latest-version","title":"Latest Version","text":"<p>The Latest version of TUD-SUMO is v3.2.3, and was released on 30/04/2025. All previous versions and their change notes can be found on GitHub or PyPI. This documentation was last updated on 13/06/2025.</p> <p>The most recent change notes are:</p>"},{"location":"#demand-profiles-plotting-improvements","title":"Demand Profiles &amp; Plotting Improvements","text":"<p>Warning</p> <p>Replacing v3.2.2 release due to error at import.</p>"},{"location":"#additions","title":"Additions","text":"<ul> <li>Added <code>DemandProfile</code> class.</li> <li>Added ability to save profiles with <code>DemandProfiles.save()</code> and added to <code>Simulation.save_objects()</code>.</li> <li>Added ability to load profiles with <code>Simulation.load_demand_profiles()</code> and <code>Simulation.load_objects()</code>.</li> <li>Added <code>Simulation.gui_is_tracking()</code> to return whether a GUI view is tracking a vehicle.</li> <li>Added <code>Simulation.get_[twt|to_depart]()</code> functions.</li> <li>Added <code>\"twt\"</code> and <code>\"to_depart\"</code> to <code>Simulation.get_interval_network_data()</code>.</li> <li>Added several view functions (<code>[add|remove]_gui_view()</code>, <code>get_gui_views()</code>, <code>get_view_[boundaries|zoom]()</code>)</li> <li>Added verbose option to Simulation initialisation.</li> <li>Added ability to plot regression line on fundamental diagrams.</li> <li>Added ability to plot labels at specific distances along trajectory diagrams and space-time diagrams.</li> <li>Added <code>MultiPlotter.plot_rm_queue_length()</code></li> <li>Added <code>\"max_queue\"</code> to metered junctions.</li> <li>Added ability to plot queue length as a percent of capacity in <code>Plotter.plot_rm_queuing()</code>.</li> <li>Added <code>Simulation.[get|set]_vehicle_type_vals()</code> to get and change vehicle type characteristics.</li> </ul>"},{"location":"#changes-improvements","title":"Changes &amp; Improvements","text":"<ul> <li>Added version to simulation start/data.</li> <li>Changed <code>recording_name</code> to <code>recording_id</code>.</li> <li>Can now create mp4/avi/gif files.</li> <li>Allowed for <code>video_filename</code> to be defined separately to <code>recording_id</code> in <code>Recorder.record_[network|vehicle]()</code>.</li> <li>Changed all GUI functions to use the main view (\"View #0\") by default.</li> <li><code>Simulation.gui_stop_tracking()</code> will now throw an error if the view is not tracking a vehicle.</li> <li>Removed traCI calls from <code>Recorder</code> class.</li> <li>Changed <code>Recorder.save_recording()</code> to only save single recordings (not by a list of IDs).</li> <li>Replaced <code>Plotter.plot_od_demand()</code> with updated <code>Plotter.plot_demand()</code> that works with <code>DemandProfile</code> objects.</li> <li>Updated ramp meter queue calculation to only include stopped vehicles.</li> <li>Updated ramp meter delay calculation to be based on vehicle speed and free-flow speed - similarly to network statistics (now also requires <code>ramp_edges</code> and not <code>queue_detector</code>).</li> <li>Maximum queue length added to <code>Plotter.plot_rm_queuing()</code>.</li> <li>Removed ability to measure queue spill back.</li> <li>(Temporarily) removed mass from custom vehicle types.</li> <li><code>Simulation.add_tracked_junctions()</code> now returns <code>TrackedJunction</code> object(s).</li> </ul>"},{"location":"#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Fixed major error in v3.2.2 causing syntax error at import.</li> <li>Fixed error when getting current travel time in <code>Simulation.get_geometry_vals()</code> (divide by zero error when average speed == 0).</li> <li>Fixed <code>Simulation.is_running()</code> not returning false if no demand profiles have been added.</li> </ul>"},{"location":"#contact","title":"Contact","text":"<p>TUD-SUMO is developed in the DAIMoND lab of TU Delft. For any questions or feedback, please contact Callum Evans at c.evans@tudelft.nl. Bug reports can be created in the GitHub repository: github.com/DAIMoNDLab/tud-sumo.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>TUD-SUMO is part of the research under the project \"AI in Network Management,\" funded by Rijkswaterstaat, grant agreement nr. 31179439, under the label of ITS Edulab.</p>"},{"location":"#citations","title":"Citations","text":"<ol> <li>\"Microscopic Traffic Simulation using SUMO\"; Pablo Alvarez Lopez, Michael Behrisch, Laura Bieker-Walz, Jakob Erdmann, Yun-Pang Fl\u00f6tter\u00f6d, Robert Hilbrich, Leonhard L\u00fccken, Johannes Rummel, Peter Wagner, and Evamarie Wie\u00dfner. IEEE Intelligent Transportation Systems Conference (ITSC), 2018.</li> </ol>"},{"location":"10_plotting/","title":"Plotting Data","text":"<p>TUD-SUMO aims to provide plotting functions with each feature. These are specifically tailored to the data collected in the <code>sim_data</code> and have a unified and standardised form. It has also been designed to facilitate plotting a large number of graphs, and graphs for different scenarios. All graphs for a specific simulation can, therefore, be saved with the same label and in specific locations.</p> <p>Two classes are provided for plotting simulation data, <code>Plotter</code> and <code>MultiPlotter</code>. <code>Plotter</code> is used for plotting data from one simulation, whilst <code>MultiPlotter</code> is used to plot data from multiple simulations. The two classes share much of the same usage, but differ in their initialisation. These shared settings and the classes themselves are explained below.</p>"},{"location":"10_plotting/#shared-settings","title":"Shared Settings","text":""},{"location":"10_plotting/#common-parameters","title":"Common Parameters","text":"<p>Whenever possible, all plotting functions (for <code>Plotter</code> and <code>MultiPlotter</code>) include <code>time_range</code> and <code>show_events</code> parameters. By default, graphs are plotted for the data throughout the whole simulation. <code>time_range</code> can be used to plot a specific duration within the simulation, and is defined in in plotter time units, ie. hours or minutes. <code>show_events</code> can either be a single event ID, list of event IDs or an event status ('scheduled', 'active' or 'completed'), which will plot all events with this status. To plot all events, set <code>show_events = \"all\"</code>. By default, no events are plotted.</p> <p>Usage examples of <code>time_range</code> and <code>show_events</code>, as well as the resulting plots are shown below.</p> <pre><code>plt = Plotter(\"example_data.pkl\", time_unit=\"minutes\")\n\n# Figure 1\nplt.plot_cumulative_curve()\n\n# Figure 2\nplt.plot_cumulative_curve(time_range=[3, 6])\n\n# Figure 3\nplt.plot_cumulative_curve(time_range=[3, 6], show_events=\"bottleneck\")\n</code></pre> <p></p>"},{"location":"10_plotting/#colours","title":"Colours","text":"<p>Certain functions use a <code>plt_colour</code> parameter that can be used to set the line colour when plotting graphs. All matplotlib colours are valid parameters. By default, TUD-SUMO uses the TU Delft colour palette as below, and so these colours are also valid parameters.</p> <p></p>"},{"location":"10_plotting/#display-saving-graphs","title":"Display &amp; Saving Graphs","text":"<p>All graphs can be saved or shown onscreen with the <code>save_fig</code> parameter. If a valid filename is given, the resulting plot is saved, otherwise, it is shown onscreen. An example is shown below.</p> <pre><code># Display trajectories graph\nplt.plot_trajectories([\"edge_1\", \"edge_2\", \"edge_3\"])\n\n# Save trajectories graph to 'figs/trajectories.png'\nplt.plot_trajectories([\"edge_1\", \"edge_2\", \"edge_3\"], save_fig=\"figs/trajectories.png\")\n</code></pre>"},{"location":"10_plotting/#plotter-class","title":"Plotter Class","text":"<p>The <code>Plotter</code> class is initialised with a single corresponding active <code>Simulation</code> object or data file from previous runs. This is the only required parameter, although the other settings are:</p> <ul> <li><code>sim_label</code>: Adds a string as a label to the title of all plots.</li> <li><code>time_unit</code>: Sets the time scale used for all plots, either 'steps', 's' (seconds), 'm' (minutes) or 'hr' (hours).</li> <li><code>save_fig_loc</code>: Sets the location for all saved figures.</li> <li><code>save_fig_dpi</code>: Resolution for saved figures.</li> <li><code>overwrite_figs</code>: Denotes whether to overwrite old figures when saving.</li> </ul> <pre><code>from tud_sumo.plot import Plotter\n\n# Simple initialisation\nplt = Plotter(my_sim)\n\nplt = Plotter(simulation=\"example_data.json\",\n              sim_label=\"Example\",\n              time_unit=\"hr\",\n              save_fig_loc=\"figs/\",\n              save_fig_dpi=400,\n              overwrite_figs=False\n             )\n</code></pre>"},{"location":"10_plotting/#plotting-functions","title":"Plotting Functions","text":"<p>Warning</p> <p>Please note that some functions will require objects to be created or tracked.</p> <p>All (current) plotting functions are listed in the table below. Several graph examples are shown beneath the table.</p> Function Plot <code>plot_vehicle_data()</code> Network-wide vehicle data such as the number of vehicles, number of waiting vehicles, Total Waiting Time (TWT), Total Time Spent (TTS) or delay. <code>plot_detector_data()</code> Detector specific data, either speeds, vehicle counts or occupancies. <code>plot_edge_data()</code> Tracked edge data, either flows, speeds, densities, vehicle counts or occupancies. <code>plot_junc_flows()</code> Either junction inflow &amp; outflow, or number of vehicles in an intersection. <code>plot_tl_colours()</code> Traffic light signal settings over time. <code>plot_demand()</code> Flow rate, either network-wide or for a specific route or an OD pair. Note, this only includes demand added to <code>DemandProfile</code>(s). <code>plot_od_trip_times()</code> Average trip times for OD pairs. <code>plot_trip_time_histogram()</code> Trip time distribution as a histogram. <code>plot_throughput()</code> Rate of completed trips in vehicles per hour. <code>plot_cumulative_curve()</code> Cumulative curve, either for network-wide data or for specific inflow and outflow detectors. <code>plot_space_time_diagram()</code> Space-time diagram based on <code>step_vehicles</code> data in tracked edges. <code>plot_trajectories()</code> Trajectories based on <code>step_vehicles</code> data in tracked edges. Use <code>lane_idx</code> to plot lane-specific data. <code>plot_fundamental_diagram()</code> Fundamental diagram based on tracked edge data. A linear regression model can be used to plot a line of best fit. <code>plot_rm_rate()</code> Metering rate for a ramp metering controller. <code>plot_rm_queuing()</code> On-ramp queue length/spillback for a ramp meter, if tracked. <code>plot_rm_rate_queuing()</code> Metering rate and queue length/spillback for a ramp meter, if tracking queuing. <code>plot_rm_rate_detector_data()</code> Metering rate and corresponding detector data. <code>plot_vsl_data()</code> Variable speed limit controller settings and average speeds on controlled edges. <code>plot_rg_data()</code> Number of vehicles diverted by a route guidance controller."},{"location":"10_plotting/#example-graphs","title":"Example Graphs","text":"<ol> <li> <p><code>plt.plot_space_time_diagram()</code> </p> </li> <li> <p><code>plt.plot_vehicle_data(data_key\"no_vehicles\", plot_cumulative=True, show_events=False, save_fig=\"n_vehicles.png\")</code> </p> </li> <li> <p><code>plt.plot_junc_flows(junc_id=\"utsc\", show_events=False, save_fig=\"junc_flows.png\")</code> </p> </li> <li> <p><code>plt.plot_tl_colours(junc_id=\"utsc\", save_fig=\"tl_colours.png\")</code> </p> </li> <li> <p><code>plt.plot_cumulative_curve(show_events=False, save_fig=\"cumulative_curve.png\")</code> </p> </li> <li> <p><code>plt.plot_trajectories([\"126730026\", \"1191885773\", \"1191885771\", \"126730171\", \"1191885772\", \"948542172\", \"70944365\", \"308977078\", \"1192621075\"], lane_idx=0, save_fig=\"trajectories.png\", show_events=False)</code> </p> </li> <li> <p><code>plt.plot_rm_rate(rm_id=\"crooswijk_meter\", show_events=False, save_fig=\"rm_rate.png\")</code> </p> </li> <li> <p><code>plt.plot_vsl_data(vsl_id=\"vsl\", show_events=False, save_fig=\"vsl_data.png\")</code> </p> </li> </ol>"},{"location":"10_plotting/#multiplotter-class","title":"MultiPlotter Class","text":"<p>The <code>MultiPlotter</code> class can be used to plot the data from multiple simulations on the same graph. During initialisation, its parameters are:</p> <ul> <li><code>scenario_label</code>: Adds a string as a label to the title of all plots.</li> <li><code>units</code>: Simulation data units, either 'metric', 'imperial' or 'uk'. This must match all added simulations.</li> <li><code>time_unit</code>: Sets the time scale used for all plots, either 'steps', 's' (seconds), 'm' (minutes) or 'hr' (hours).</li> <li><code>sim_data_loc</code>: Sets the location for all simulation datasets.</li> <li><code>save_fig_loc</code>: Sets the location for all saved figures.</li> <li><code>save_fig_dpi</code>: Resolution for saved figures.</li> <li><code>overwrite_figs</code>: Denotes whether to overwrite old figures when saving.</li> </ul> <p>Once the <code>MultiPlotter</code> object has been created, simulation datasets are added using the <code>MultiPlotter.add_simulations()</code> function. After this, all added datasets are plotted on all graphs. Datasets can either be plotted individually or in groups, where graphs will show the minimum, maximum and average values. Note that datasets can only be added through a previously saved <code>sim_data</code> file, and cannot be an active simulation as with <code>Plotter</code>.</p> <p>There are four parameters for <code>MultiPlotter.add_simulations()</code>:</p> <ul> <li><code>simulations</code>: A list of filenames of <code>sim_data</code> files. This can also be a single filename.</li> <li><code>labels</code>: A list of labels for each simulation, which must have the same length as <code>simulations</code>. If <code>labels</code> is not given, datasets use their scenario name as the label.</li> <li><code>groups</code>: A list of group names, or a single group. If a list is given, the list must have the same length as <code>simulation</code> and datasets are assigned groups element-wise. If a single group ID is given, all datasets listed in <code>simulations</code> are included in this group.</li> <li><code>pbar</code>: A boolean denoting whether to show a progress bar when loading datasets.</li> </ul> <p>Warning</p> <p>All simulation datasets must have the same start time, end time, step length and unit. It is assumed all datasets correspond to the same scenario.</p> <p>An example usage of this is shown below:</p> <pre><code>from tud_sumo.plot import MultiPlotter\n\nmplt = MultiPlotter(scenario_label=\"RL Models\", # Add 'RL Models' as a label to all graphs\n                    sim_data_loc=\"data/\",       # All sim_data files are loaded from 'data/'\n                    save_fig_loc=\"figs/\",       # All graphs will be saved in 'figs/'\n                    time_unit=\"hours\")          # Use 'hours' as the unit for all graphs\n\n# Add a single no-control simulation dataset\n# 'no_control.pkl' will be plotted individually\nmplt.add_simulations(\"no_control.pkl\")\n\n# Add 3 simulation datasets, all in the 'baseline' group\n# These datasets will be plotted together, with the minimum/maximum and average values\nmplt.add_simulations([\"baseline1.pkl\", \"baseline2.pkl\", \"baseline3.pkl\"], groups=\"baseline\")\n\n# Add 3 simulation datasets, defining a label for each\n# No groups are assigned, so all datasets will be plotted individually\nmplt.add_simulations([\"model1.pkl\", \"model2.pkl\", \"model3.pkl\"], labels=[\"Model 1\", \"Model 2\", \"Model 3\"])\n\n# Add 4 simulation datasets, split into two groups\n# 'model4a/b.pkl' and 'model5a/b.pkl' will both be grouped together\nmplt.add_simulations([\"model4a.pkl\", \"model4b.pkl\", \"model5a.pkl\", \"model5b.pkl\"],\n                     groups=[\"Model 4\", \"Model 4\", \"Model 5\", \"Model 5\"])\n</code></pre>"},{"location":"10_plotting/#plotting-functions_1","title":"Plotting Functions","text":"<p>The available functions in the <code>MultiPlotter</code> class are listed below. All functions use 2 extra parameters than in the <code>Plotter</code> class; <code>plot_groups</code> and <code>plot_range</code>. <code>plot_groups</code> allows for only specific groups to be plotted by passing a list of dataset group IDs. By default, all groups are plotted. <code>plot_range</code> denotes whether to plot the shaded region between minimum and maximum values of groups on certain graphs.</p> <ol> <li><code>mplt.plot_vehicle_data(\"tts\")</code> </li> <li><code>mplt.plot_detector_data(\"upstream_i0\", \"speeds\", aggregation_steps=10)</code> </li> <li><code>mplt.plot_edge_data(\"downstream_e1\", \"densities\", aggregation_steps=10)</code> </li> <li><code>mplt.plot_throughput()</code> </li> <li><code>mplt.plot_statistics(\"tts\")</code> </li> <li><code>mplt.plot_rm_rate(\"ramp_meter_id\")</code> </li> <li><code>plot_rm_queue_length(\"crooswijk_meter\")</code> </li> </ol>"},{"location":"11_examples/","title":"Examples","text":""},{"location":"11_examples/#basic-scenario","title":"Basic Scenario","text":"<p>Below is a basic example that can be used to check that SUMO and TUD-SUMO are installed and run correctly. The network used is shown above, and is a simple ~300m stretch of road with a constant demand of 1800veh/hr.</p> <p>This example can be downloaded from the <code>basic_example</code> file on GitHub at: DAIMoNDLab/tud-sumo-examples</p> <pre><code>from tud_sumo.simulation import Simulation\n\nif __name__ == \"__main__\":\n\n    # Initialise the simulation object.\n    my_sim = Simulation(scenario_name=\"basic_scenario\",\n                        scenario_desc=\"TUD-SUMO integrity check.\")\n\n    # Start the simulation, defining the sumo config files.\n    my_sim.start(\"basic_scenario/sumo_config.sumocfg\",\n                 gui=True,\n                 seed=1)\n\n    # Run through the simulation for 1000 steps.\n    my_sim.step_through(n_steps=1000)\n\n    # End the simulation.\n    my_sim.end()\n\n    # Save the simulation data &amp; print a summary, which is also saved.\n    my_sim.save_data(\"example_data.json\")\n    my_sim.print_summary(save_file=\"example_summary.txt\")\n</code></pre>"},{"location":"11_examples/#a20-scenario","title":"A20 Scenario","text":"<p>Below, the northern section of the motorway ringroad around Rotterdam, the A20 between Schiedam and the Kralingse Bos, is simulated. This scenario aims to demonstrate the full functionality of TUD-SUMO, with multiple ramp meters, variable speed limit and route guidance controllers, as well as several different events and interactions. The layout of the network itself is shown above.</p> <p>This example can be downloaded from the <code>a20_example</code> file on GitHub at: DAIMoNDLab/tud-sumo-examples</p> <pre><code>from random import randint, seed\nimport sys\n\nfrom tud_sumo.simulation import Simulation\nfrom tud_sumo.plot import Plotter\n\nif __name__ == \"__main__\":\n\n    # Initialise the simulation object.\n    my_sim = Simulation(scenario_name=\"A20_ITCS\", scenario_desc=\"Example traffic controllers, with 2 ramp meters, 1 VSL controller and 1 route guidance controller.\")\n\n    sim_seed = \"1\" if \"-seed\" not in sys.argv[:-1] else sys.argv[sys.argv.index(\"-seed\")+1]\n    seed(int(sim_seed))\n\n    # Start the simulation, defining the sumo config files.\n    my_sim.start(\"example_scenario/a20.sumocfg\", get_individual_vehicle_data=False, gui=\"-gui\" in sys.argv,\n                 seed=sim_seed, units=\"metric\") # Units can either be metric (km,kmph)/imperial (mi,mph)/UK (km,mph). All data collected is in these units.\n\n    # Add demand from a '.csv' file.\n    # my_sim.load_demand(\"example_scenario/demand.csv\")\n\n    # Add a tracked junction to the intersection with ID \"utsc\", which will track signal phases/times.\n    my_sim.add_tracked_junctions({\"utsc\": {\"flow_params\": {\"inflow_detectors\": [\"utsc_n_in_1\", \"utsc_n_in_2\", \"utsc_w_in\", \"utsc_e_in\"],\n                                                        \"outflow_detectors\": [\"utsc_w_out\", \"utsc_e_out\"],\n                                                        \"vehicle_types\": [\"cars\", \"lorries\", \"motorcycles\", \"vans\"]}}})\n\n    # Set traffic signal phases. The junc_phases dict can be used for multiple junctions.\n    my_sim.set_phases({\"utsc\": {\"phases\": [\"GGrr\", \"yyrr\", \"rrGG\", \"rryy\"], \"times\": [27, 3, 17, 3]}})\n\n    # Add a ramp meter to the junction with ID \"crooswijk_meter\". The junc_params dict can be used to\n    # define meter specifc parameters (min/max rate, spillback tracking or queue detectors) and flow specific\n    # parameters (inflow/outflow detectors used to calculate in/out flow).\n    my_sim.add_tracked_junctions({\"crooswijk_meter\": {'meter_params': {'min_rate': 200, 'max_rate': 2000, 'queue_detector': \"cw_ramp_queue\"},\n                                                    'flow_params': {'inflow_detectors': [\"cw_ramp_inflow\", \"cw_rm_upstream\"], 'outflow_detectors': [\"cw_rm_downstream\"]}},\n                                \"a13_meter\": {'meter_params': {'min_rate': 200, 'max_rate': 2000, 'queue_detector': \"a13_ramp_queue\"},\n                                                'flow_params': {'inflow_detectors': [\"a13_ramp_inflow\", \"a13_rm_upstream\"], 'outflow_detectors': [\"a13_rm_downstream\"]}}})\n\n    # Add Route Guidance (RG) &amp; Variable Speed Limit (VSL) controllers. RG controllers need a detector or\n    # edge that will act as the redirection point and a target edge/route ID to redirect drivers to. It is\n    # also possible to define a diversion percent to randomly divert a certain percent of drivers, and a\n    # highlight colour for the SUMO gui, which will highlight affected drivers. VSL controllers only need\n    # to have a list of lanes/edges where they will operate.\n    my_sim.add_controllers({\"rerouter\": {\"type\": \"RG\", \"detector_ids\": [\"rerouter_2\"], \"new_destination\": \"urban_out_w\", \"diversion_pct\": 1, \"highlight\": \"00FF00\"},\n                            \"vsl\": {\"type\": \"VSL\", \"geometry_ids\": [\"126729982\", \"126730069\", \"126730059\"]}})\n\n    # Add tracked edges. This will track some basic information, such as average speed etc, but can also\n    # be used to create space-time diagrams as individual vehicle speeds and positions are tracked.\n    tracked_edges = [\"126730026\", \"1191885773\", \"1191885771\", \"126730171\", \"1191885772\", \"948542172\", \"70944365\", \"308977078\", \"1192621075\"]\n    my_sim.add_tracked_edges(tracked_edges)\n\n    # Add scheduled events from a JSON file (can be dictionary). Use the format as in example_incident.json\n    my_sim.add_events(\"example_scenario/example_incident.json\")\n\n    # Add a new route that vehicles can be assigned to.\n    my_sim.add_route((\"urban_in_e\", \"urban_out_w\"), \"new_route\")\n\n    # These individual functions above can be replaced as below, where the 'parameters.json' file contains\n    # a dictionary of all necessary parameters (under 'edges', 'junctions', 'phases', 'controllers' and 'events')\n    # my_sim.load_objects(\"parameters.json\")\n\n    # This file can either be created manually, or by saving objects in previous simulations. This is done\n    # using the save_objects function as below.\n    my_sim.save_objects(\"objects.json\")\n\n    # Add a function that is called on each new vehicle in the simulation. Simulation parameters are; curr_step,\n    # vehicle_id, route_id, vehicle_type, departure, origin, destination. These values are filled automatically.\n    # For other parameters, use a parameters dictionary as below. Use add_vehicle_out_funcs() for functions\n    # called when vehicles exit the simulation (only with vehicle_id and/or curr_step). Vehicle in/out functions\n    # can be removed using remove_vehicle_[in/out]_functions().\n\n    vehicle_ids, new_veh_idx = [], 0\n    def add_to_vehicle_arr(simulation, vehicle_id, arr):\n        \"\"\"\n        Append vehicle ID and initial speed to an array.\n        \"\"\"\n        veh_speed = simulation.get_vehicle_vals(vehicle_id, \"speed\")\n        arr.append((vehicle_id, veh_speed))\n\n    my_sim.add_vehicle_in_functions(add_to_vehicle_arr, parameters={\"arr\": vehicle_ids})\n\n    n, sim_dur, warmup = 1, 500 / my_sim.step_length, 0 / my_sim.step_length\n\n    if warmup &gt; 0:\n        my_sim.step_through(n_steps=warmup, pbar_max_steps=sim_dur+warmup, keep_data=False)\n\n    while my_sim.curr_step &lt; sim_dur + warmup:\n\n        # Set ramp metering rate.\n        if my_sim.curr_step % 50 / my_sim.step_length == 0:\n            my_sim.set_tl_metering_rate(rm_id=\"crooswijk_meter\", metering_rate=randint(1200, 2000))\n            my_sim.set_tl_metering_rate(rm_id=\"a13_meter\", metering_rate=randint(1200, 2000))\n\n        # Step through n seconds.\n        my_sim.step_through(n_seconds=n, pbar_max_steps=sim_dur+warmup)\n\n        # Add new vehicles going from \"urban_in_e\" to \"urban_out_w\" (using previously defined route)\n        if my_sim.curr_step % 50 / my_sim.step_length == 0:\n            my_sim.add_vehicle(vehicle_id=\"lorry_\"+str(new_veh_idx), vehicle_type=\"lorries\", routing=\"new_route\", origin_lane=\"first\")\n            my_sim.add_vehicle(vehicle_id=\"car_\"+str(new_veh_idx), vehicle_type=\"cars\", routing=\"new_route\")\n            new_veh_idx += 1\n\n        if my_sim.curr_step == 100 / my_sim.step_length:\n            my_sim.cause_incident(100, n_vehicles=2, edge_speed=5)\n\n        if my_sim.curr_step == 250 / my_sim.step_length:\n            # Activate controllers &amp; update UTSC phases.\n            my_sim.controllers[\"rerouter\"].activate()\n            my_sim.controllers[\"vsl\"].set_speed_limit(60)\n\n            my_sim.set_phases({\"utsc\": {\"phases\": [\"GGrr\", \"yyrr\", \"rrGG\", \"rryy\"], \"times\": [37, 3, 7, 3]}}, overwrite=False)\n\n        if my_sim.curr_step == 400 / my_sim.step_length:\n            my_sim.controllers[\"vsl\"].set_speed_limit(40)\n\n        # Deactivate controllers.\n        if my_sim.curr_step == 450 / my_sim.step_length:\n            my_sim.controllers[\"rerouter\"].deactivate()\n            my_sim.controllers[\"vsl\"].deactivate()\n\n    # End the simulation.\n    my_sim.end()\n\n    # Save the simulation data &amp; print a summary, which is also saved.\n    my_sim.save_data(\"example_data.json\")\n    my_sim.save_data(\"example_data.pkl\")\n    my_sim.print_summary(save_file=\"example_summary.txt\")\n</code></pre>"},{"location":"2_getting_started/","title":"Getting Started","text":""},{"location":"2_getting_started/#requirements","title":"Requirements","text":"<p>To run TUD-SUMO, first install SUMO. Platform-specific information on how to do this can be found in the SUMO documentation: sumo.dlr.de/docs/Installing/</p> <p>Once SUMO has been installed, ensure that the <code>SUMO_HOME</code> variable has been set in your environment. This should be set to the base directory of your SUMO installation. Information on how to do this can be found here: sumo.dlr.de/docs/Basics/Basic_Computer_Skills.html</p> <p>Python 3.10 or later is required to run TUD-SUMO, otherwise, the required dependencies are:</p> <ul> <li><code>traci</code></li> <li><code>sumolib</code></li> <li><code>matplotlib</code></li> <li><code>mpl-tools</code></li> <li><code>shapely</code></li> <li><code>requests</code></li> <li><code>tqdm</code></li> <li><code>moviepy</code></li> </ul>"},{"location":"2_getting_started/#creating-an-environment","title":"Creating an Environment","text":"<p>Although not required, it is recommended to use install the required packages in an environment, such as using Anaconda or Miniconda. A conda environment ready for TUD-SUMO can be created using the following commands.</p> <pre><code>conda create --name tud-sumo\nconda activate tud-sumo\nconda install matplotlib tqdm\npip install traci sumolib mpl-tools shapely requests\n</code></pre> <p>Conda can then be deactivated later using the command:</p> <pre><code>conda deactivate tud-sumo\n</code></pre>"},{"location":"2_getting_started/#installation","title":"Installation","text":"<p>TUD-SUMO is available on PyPI, and can be installed using the following command below. More information and previous release versions can be found on PyPI.</p> <pre><code>pip install tud-sumo\n</code></pre> <p>To install a specific version of TUD-SUMO, use:</p> <pre><code>pip install tud-sumo==3.0.4\n</code></pre>"},{"location":"3_basic_sim/","title":"Basic Simulations","text":""},{"location":"3_basic_sim/#sumo-scenarios","title":"SUMO Scenarios","text":"<p>Before anything can be simulated, all the necessary SUMO scenario files are required. This will typically include a '.sumocfg', '.neteditcfg', '.net.xml', '.rou.xml' and '.add.xml'. The simplest way to create a scenario and these files is using netedit, about which there is more information here.</p>"},{"location":"3_basic_sim/#initialising-the-simulation","title":"Initialising the Simulation","text":"<p>All simulations in TUD-SUMO are created and run using the <code>Simulation</code> class, which is initialised as below. A scenario name and description are optional, but can be useful when running multiple similar simulations.</p> <pre><code>from tud_sumo.simulation import Simulation\n\nmy_sim = Simulation(scenario_name=\"example\", scenario_desc=\"Example simulation.\")\n</code></pre> <p>To then start the simulation and create the connection to SUMO through TraCI, use <code>Simulation.start()</code>. This can very easily be done using the '.sumocfg' file created by netedit, which links all to all other files, however, the <code>net_file</code>, <code>route_file</code>, <code>add_file</code> and <code>gui_file</code> parameters can also be used to give each file individually. Whether or not to use the GUI is also set here, although note this cannot be changed throughout the simulation.</p> <pre><code>my_sim.start(\"example_scenario.sumocfg\",\n             gui=True,\n             get_individual_vehicle_data=False,\n             units=\"metric\",\n             suppress_pbar=False,\n             seed=1\n            )\n</code></pre> <p>The <code>get_individual_vehicle_data</code> is an important parameter denoting whether to collect and save dynamic information for all vehicles (ie. position, speed, acceleration etc.) at each step. This can be useful for small scenarios where this data may be required and computation time is less of an issue, such as single intersections, however, this should be set to false for large scenarios, such as large motorway networks.</p> <p>3 unit settings are supported 'metric' (km/kmph), 'imperial' (mi/mph) and 'UK' (km/mph). All data collected and saved are in these units, and this setting cannot be changed later.</p> <p>The <code>seed</code> parameter is optional and affects both the SUMO simulation and the <code>Simulation</code> class. Random seeds in SUMO primarily affects how vehicles are added into the simulation (more information can be found here). The seed can be set to random either by not using the parameter or by setting it to 'random'.</p> <p>By default, a progress bar is automatically created when simulating more than 10 steps at a time. This can be skipped by setting <code>suppress_pbar = False</code>. </p> <p>Tracked junctions/edges, controllers etc. can be initialised at this point. These objects can be added individually, or if all of their parameters are saved in a dictionary or '.json' or '.pkl' file, these can be read using the <code>Simulation.load_objects()</code> function. This dictionary can be created manually, or can be saved with <code>Simulation.save_objects()</code> for ease of use. An example of this resulting file can be found here, otherwise, more information on the objects themselves can be found in their respective sections.</p> <pre><code># Save object initialisation parameters\nmy_sim.save_objects(\"objects.pkl\")\n\n# Initialise objects using the same parameters\nmy_sim.load_objects(\"objects.pkl\")\n</code></pre> <p>The following objects can be included in this dictionary:</p> <ul> <li>'edges': List of edge IDs for tracking.</li> <li>'junctions': Tracked junction initialisation parameters.</li> <li>'phases': Traffic light phase dictionary.</li> <li>'controllers': Dictionary containing VSL and/or RG controller parameters.</li> <li>'events': Dictionary containing scheduled event parameters (previous dynamic events are saved in the resulting file).</li> <li>'demand': Dictionary containing a demand profile table. These are made by creating a demand profile and saving using <code>Simulation.save_objects()</code>. </li> <li>'routes': A dictionary containing new routes by their ID and a (2x1) array representing the origin and destination.</li> </ul>"},{"location":"3_basic_sim/#running-the-simulation","title":"Running the Simulation","text":"<p>The simulation is run using the <code>Simulation.step_through()</code> function. When no parameters are given, the simulation will run through one step by default. Otherwise, using <code>n_steps</code> will run the simulation for a specific number of steps, <code>end_step</code> will run the simulation until a specific step and <code>n_seconds</code> will run the simulation for a specific amount of time (in seconds).</p> <pre><code># Run 1 step\nmy_sim.step_through()\n\n# Run for 100 steps\nmy_sim.step_through(100)\n\n# Run until step 200\nmy_sim.step_through(end_step=200)\n\n# Run for 100 seconds (where step length = 0.5)\nmy_sim.step_through(n_seconds=200)\n</code></pre> <p>A control loop can, therefore, be created as below. A progress bar is automatically created when simulating for 10 or more steps in one call of <code>Simulation.step_through()</code>. In order to create a progress bar that is consistent between separate calls, use the <code>pbar_max_steps</code> parameter and set this to the total length of the simulation.</p> <pre><code>n, sim_dur = 100, 2500\nwhile my_sim.curr_step &lt; sim_dur: # or use my_sim.curr_time\n\n    # Step through n steps.\n    my_sim.step_through(n_steps=n, pbar_max_steps=sim_dur)\n\n    # Perform control\n    # ...\n</code></pre> <p>To include a warmup period where no data is collected, set <code>keep_data = True</code>.</p> <pre><code>warmup_length = 120\nmy_sim.step_through(n_seconds=warmup_length, keep_data=True)\n</code></pre>"},{"location":"3_basic_sim/#ending-the-simulation","title":"Ending the Simulation","text":"<p>A simulation can be run until it is finished as below. The <code>Simulation.is_running()</code> function returns false once the simulation is over, which is determined as happening once all defined vehicles have finished their run through the simulation. It is then best to end the simulation using <code>Simulation.end()</code>, which closes the connection to TraCI.</p> <pre><code>while my_sim.is_running():\n    my_sim.step_through()\n\nmy_sim.end()\n</code></pre>"},{"location":"3_basic_sim/#automatic-data-collection","title":"Automatic Data Collection","text":"<p>One of the major advantages of TUD-SUMO is the automatic data collection. This involves automatically collecting all basic simulation information into a <code>sim_data</code> dictionary. An example of this can be seen in examples directory in the main TUD-SUMO repository, however, the main structure is as follows:</p> <pre><code>{\n    \"data\":\n        {\n            \"detectors\": {},\n            \"junctions\": {},\n            \"edges\": {},\n            \"controllers\": {},\n            \"vehicles\": {},\n            \"demand\": {},\n            \"trips\": {},\n            \"events\": {},\n            \"all_vehicles\": {}\n        },\n    \"start\": 0,\n    \"end\": 1000,\n    \"step_len\": 1.0,\n    \"units\": \"METRIC\",\n    \"seed\": 10,\n    \"sim_start\": \"08/07/2024, 13:00:00\",\n    \"sim_end\": \"08/07/2024, 13:00:10\"\n}\n</code></pre> <p>Detectors will automatically collect vehicle speeds and counts for each time step, as well as the IDs of each vehicle that passed over it, whilst occupancies are also collected for mutli-entry-exit detectors. These will be stored under 'data/detectors/{detector_id}', with 'type', 'position', 'speeds', 'vehicle_counts', 'vehicle_ids' and 'occupancies'.</p> <p>Vehicle data will include the number of vehicles at each step, 'twt' (No. waiting vehicles * step length), 'tts' (N. vehicles * step length), 'delay' (calculated based on vehicle speed and ideal free-flow speed) and 'to_depart' (the number of vehicles waiting to be inserted at each time step).</p> <p>Demand is only included when dynamically adding demand, ie. not when demand is solely defined in the '.rou.xml' file. This dictionary will contain two objects; 'headers' and a list of demand profile tables. Each table in 'profiles' will contain a (9 x n) sized array with information on flows added through demand profiles, with its headers listed under 'headers'.</p> <p>Trip data will contain data for incomplete and completed trips. This is stored under 'data/trips' and then either 'incomplete' or 'completed'. Each trip will store the 'route_id', 'vehicle_type', 'departure', 'arrival' (or removal), 'origin' and 'destination'.</p> <p>Junction, edge, controller and event data are only included when necessary. The <code>all_vehicles</code> data will contain all the individual vehicle data at each time step, so it is only included when <code>get_individual_vehicle_data</code> is set to true when starting the simulation.</p> <p>The <code>sim_data</code> dictionary can be reset at any point using the <code>Simulation.reset_data()</code> function.</p> <pre><code>my_sim.reset_data()\n</code></pre>"},{"location":"3_basic_sim/#saving-summarising-data","title":"Saving &amp; Summarising Data","text":"<p>All the data collected throughout the simulation can be saved at any point using the <code>Simulation.save_data()</code> function. This will save the <code>sim_data</code> dictionary as a file in the specified directory. Either JSON or pickle files are supported, simply denoted by a '.json' or '.pkl' extension in the filename.</p> <pre><code>my_sim.save_data(\"data/example_data.json\")\nmy_sim.save_data(\"data/example_data.pkl\")\n</code></pre> <p>All data saved by a simulation or a simulation data file can be summarised using the <code>Simulation.print_summary()</code> or <code>print_summary()</code> functions. This will print a summary of the collected data (ie. number of vehicles, TTS, controllers, events etc.), as well as some information about the simulation itself (ie. scenario name/description, runtime, seed etc.). This summary can be saved to a '.txt' file using the <code>save_file</code> parameter. An example summary is shown below.</p> <pre><code>my_sim.print_summary(save_file=\"data/example_summary.txt\")\n\n# Print summary without creating a Simulation object\nfrom tud_sumo.simulation import print_summary\nprint_summary(\"data/example_data.pkl\")\n</code></pre> <pre><code> *============================================================*\n |                      TUD-SUMO v3.2.2                       | \n *============================================================*\n |                          A20_ITCS                          | \n *============================================================*\n |                        Description:                        | \n |   Example traffic controllers, with 2 ramp meters, 1 VSL   | \n |        controller and 1 route guidance controller.         | \n *============================================================*\n |                 Simulation Run: 25/03/2025                 | \n |               17:13:43 - 17:13:58 (0:00:15)                | \n *------------------------------------------------------------*\n | Number of Steps:                               500 (0-500) | \n | Step Length:                                          1.0s | \n | Avg. Step Duration:                                  0.03s | \n | Units Type:                              Metric (km, km/h) | \n | Seed:                                                    1 | \n *============================================================*\n |                            Data                            | \n *============================================================*\n |                        Vehicle Data                        | \n *------------------------------------------------------------*\n |                       No. Vehicles:                        | \n | Average:                                            736.24 | \n | Peak:                                                 1211 | \n | Final:                                                1211 | \n | Overall TTS:                                       368118s | \n * ---------------------------------------------------------- *\n |                   No. Waiting Vehicles:                    | \n | Average:                                             23.43 | \n | Peak:                                                   69 | \n | Final:                                                  55 | \n | Overall TWT:                                        11713s | \n * ---------------------------------------------------------- *\n |                       Vehicle Delay:                       | \n | Average:                                           392.71s | \n | Peak:                                              788.69s | \n | Final:                                              783.1s | \n | Cumulative Delay:                               196352.73s | \n * ---------------------------------------------------------- *\n |                    Vehicles to Depart:                     | \n | Average:                                           1063.27 | \n | Peak:                                                 2227 | \n | Final:                                                2227 | \n * ---------------------------------------------------------- *\n | Individual Data:                                        No | \n *------------------------------------------------------------*\n |                         Trip Data                          | \n *------------------------------------------------------------*\n | Incomplete Trips:                            1213 (65.18%) | \n | Completed Trips:                               648 (34.8%) | \n *------------------------------------------------------------*\n |                         Detectors                          | \n *------------------------------------------------------------*\n |               Induction Loop Detectors: (15)               | \n |       a13_ramp_inflow, cw_down_occ_0, cw_down_occ_1,       | \n |  cw_down_occ_2, cw_down_occ_3, cw_up_occ_0, cw_up_occ_1,   | \n |      cw_up_occ_2, rerouter_2, utsc_e_in, utsc_e_out,       | \n |      utsc_n_in_1, utsc_n_in_2, utsc_w_in, utsc_w_out       | \n |                                                            | \n |              Multi-Entry-Exit Detectors: (7)               | \n |    a13_ramp_queue, a13_rm_downstream, a13_rm_upstream,     | \n |      cw_ramp_inflow, cw_ramp_queue, cw_rm_downstream,      | \n |                       cw_rm_upstream                       | \n *------------------------------------------------------------*\n |                       Tracked Edges                        | \n *------------------------------------------------------------*\n | 126730026, 1191885773, 1191885771, 126730171, 1191885772,  | \n |         948542172, 70944365, 308977078, 1192621075         | \n *------------------------------------------------------------*\n |                     Tracked Junctions                      | \n *------------------------------------------------------------*\n |                     utsc (Signalised)                      | \n |           crooswijk_meter (Signalised, Metered)            | \n |              a13_meter (Signalised, Metered)               | \n *------------------------------------------------------------*\n |                        Controllers                         | \n *------------------------------------------------------------*\n |                    Route Guidance: (1)                     | \n |                          rerouter                          | \n |                                                            | \n |                 Variable Speed Limits: (1)                 | \n |                            vsl                             | \n *------------------------------------------------------------*\n |                    Event IDs &amp; Statuses                    | \n *------------------------------------------------------------*\n |                 Active: incident_response                  | \n |             Completed: incident_1, bottleneck              | \n *------------------------------------------------------------*\n</code></pre> <p>The structure of a simulation data file can also be printed using the <code>Simulation.print_sim_data_struct()</code> or <code>print_sim_data_struct()</code> functions. This will print the structure of the <code>sim_data</code> dictionary as a tree, allowing you to see the exact keys and data types used in the data. An example of the output of <code>print_sim_data_struct()</code> is shown below.</p> <p>Note that the dimensions of array are only displayed up to 2D. If an array has a higher dimension, this is denoted by a '+'. If the array is inhomogeneous (ie. its dimensions are inconsistent), this is denoted by a '*' and the array's maximum size is shown.</p> <pre><code>my_sim.print_sim_data_struct()\n\n# Print structure without creating a Simulation object\nfrom tud_sumo.simulation import print_sim_data_struct\nprint_sim_data_struct(\"data/example_data.pkl\")\n</code></pre> <pre><code>A20_ITCS:\n  \u251c\u2500- scenario_name: str\n  \u251c\u2500- scenario_desc: str\n  \u251c\u2500- tuds_version: str\n  \u251c\u2500- data:\n  |     \u251c\u2500- detectors:\n  |     |     \u251c\u2500- a13_ramp_queue:\n  |     |     |     \u251c\u2500- type: str\n  |     |     |     \u251c\u2500- position:\n  |     |     |     |     \u251c\u2500- entry_lanes: tuple (1x1)\n  |     |     |     |     \u251c\u2500- exit_lanes: tuple (1x1)\n  |     |     |     |     \u251c\u2500- entry_positions: tuple (1x1)\n  |     |     |     |     \u2514\u2500- exit_positions: tuple (1x1)\n  |     |     |     \u251c\u2500- speeds: list (1x500)\n  |     |     |     \u251c\u2500- vehicle_counts: list (1x500)\n  |     |     |     \u2514\u2500- vehicle_ids: list (500x28*)\n  .     .     .\n  .     .     .\n  .     .     .\n  |     \u251c\u2500- vehicles:\n  |     |     \u251c\u2500- no_vehicles: list (1x500)\n  |     |     \u251c\u2500- no_waiting: list (1x500)\n  |     |     \u251c\u2500- tts: list (1x500)\n  |     |     \u251c\u2500- twt: list (1x500)\n  |     |     \u251c\u2500- delay: list (1x500)\n  |     |     \u2514\u2500- to_depart: list (1x500)\n  |     \u2514\u2500- trips:\n  |           \u251c\u2500- incomplete: dict (1x1213)\n  |           \u2514\u2500- completed: dict (1x648)\n  \u251c\u2500- start: int\n  \u251c\u2500- end: int\n  \u251c\u2500- step_len: float\n  \u251c\u2500- units: str\n  \u251c\u2500- seed: int\n  \u251c\u2500- sim_start: str\n  \u2514\u2500- sim_end: str\n</code></pre>"},{"location":"4_demand/","title":"Traffic Demand","text":""},{"location":"4_demand/#demand-profiles","title":"Demand Profiles","text":"<p>There are two approaches to adding demand to a simulation. The default approach is to define demand with routes or by flow within a '.rou.xml' file, in which case, nothing else needs to be done. Alternatively, demand can be generated more dynamically within TUD-SUMO. This is done using a <code>DemandProfile</code> object, intialised as below with a corresponding <code>Simulation</code> object.</p> <pre><code>from tud_sumo.simulation import Simulation\nfrom tud_sumo.demand import DemandProfile\n\nmy_sim = Simulation(scenario_name=\"example\", scenario_desc=\"Example simulation.\")\nmy_sim.start(\"example_scenario.sumocfg\")\n\ndp = DemandProfile(my_sim)\ndp2 = DemandProfile(my_sim)\n</code></pre> <p>Once the profile has been created, there are 3 ways to add demand; <code>DemandProfile.load_demand()</code>, <code>DemandProfile.add_demand()</code> or <code>DemandProfile.add_demand_function()</code>. All demand from a profile can also be plotted using <code>DemandProfile.plot_demand()</code> or <code>Plotter.plot_demand()</code>.</p> <p>Multiple demand profiles can be added to one simulation object, and can be controlled independently.</p>"},{"location":"4_demand/#loading-demand","title":"Loading Demand","text":"<p><code>DemandProfile.load_demand()</code> can be used to load a pre-defined demand profile from a '.csv' file, in the format below. For a route, either an 'origin' and 'destination' or a 'route_id' is required. If using a route ID, the route must be pre-defined in the '.rou.xml' file. A time range for the demand is also required, either with a 'start_time/end_time' or 'start_step/end_step'. This time range is defined in seconds. The demand value can either be given as a flow value in vehicles/hour under 'demand' or as a raw number of vehicles under 'number'.</p> <pre><code># Add multiple demands to the same profile\ndp.load_demand(\"base_demand.csv\")\ndp.load_demand(\"peak_demand.csv\")\n</code></pre> <p>If a flow value is given, vehicles are spawned throughout the demand period at this specified rate. Vehicles are inserted into the simulation using a Gaussian distribution with an average of 'demand' vehicle per hour. 'insertion_sd' is an optional float parameter that can be used to change the standard deviation of this distribution, and defaults to 1/3. Note that the actual standard deviation used is calculated using demand * insertion_sd. When the vehicles per step is below 1, vehicles are inserted at each step with this rate as a probability.</p> <p>The other parameters are optional. 'vehicle_types' can be a list of vehicle type IDs or a single ID and can optionally be given with 'vehicle_type_dists'. When adding demand of multiple potential vehicle types, this allows for the distribution of types to be defined. If 'vehicle_types', the default vehicle type is used, and when 'vehicle_types' is given without a 'vehicle_type_dists', vehicle types have an equal distribution. 'initial_speed' defines the initial speed of vehicles at insertion and can either be 'max', 'random' or a number &gt; 0, but defaults to 'max'. 'origin_lane' defines which lane vehicles are inserted at. This can either be 'random', 'free', 'allowed', 'best', 'first' or a specific lane index, but defaults to 'best'. 'origin_pos' defines the longitudinal position on the lane vehicles are inserted at. This can either be 'random', 'free', 'random_free', 'last', 'stop', 'splitFront' or a specific position, but defaults to 'base'. 'colour' can either be a hex code, list of RGB(A) values or a valid sumo colour.</p> <p>More in-depth descriptions of the possible values can be found here. Two examples of the contents of a 'demand.csv' file are shown below.</p> origin destination start_time end_time demand vehicle_types vehicle_type_dists colour edge_1 edge_10 0 600 1200 \"cars,vans,lorries\" \"0.7,0.2,0.1\" red ... ... ... ... ... ... ... ... route_id start_step end_step number initial_speed origin_lane origin_pos insertion_sd route_1 0 1200 200 max 1 random 0.3 ... ... ... ... ... ... ... ..."},{"location":"4_demand/#adding-flows","title":"Adding Flows","text":"<p>Demand can also be added using the <code>DemandProfile.add_demand()</code> function. This uses the same set of parameters as the demand files above, except 'origin/destination/route_id' is replaced by a single <code>routing</code> parameter, and <code>step_range</code> is used instead of 'start_time/end_time' or 'start_step/end_step'. Demand is defined as a flow rate in vehicles/hour. Examples are shown below.</p> <pre><code># Add vehicles, allowing them to use the most optimal route\n# between 'edge_1' and 'edge_10' (found based on current conditions)\ndp.add_demand(routing=(\"edge_1\", \"edge_10\"),\n              step_range=(0, 1200),\n              demand=1200,\n              vehicle_types=[\"cars\", \"vans\", \"lorries\"],\n              vehicle_type_dists=[0.7, 0.2, 0.2],\n              colour=\"#FF0000\"\n             )\n\n# Add vehicles to a specific (pre-defined) route\ndp.add_demand(routing=\"route_1\",\n              step_range=(0, 1200),\n              demand=200,\n              initial_speed=\"max\",\n              origin_lane=1,\n              colour=\"magenta\"\n             )\n</code></pre>"},{"location":"4_demand/#demand-functions","title":"Demand Functions","text":"<p>Lastly, demand can be added using a demand function that calculates demand based on the step number. This is done using the <code>DemandProfile.add_demand_function()</code> function, which again uses the same parameters as <code>DemandProfile.add_demand()</code>, except <code>demand</code> is replaced by <code>demand_function</code> and <code>parameters</code>. <code>demand_function</code> is a function that takes <code>step</code>, the step number, as a parameter and outputs a flow value based on this. Other parameters can be passed into the function using a <code>parameters</code> dictionary.</p> <p>An example of this is shown below, where a demand function <code>cos()</code> generates a demand profile using a cosine function.</p> <pre><code>def cos(step, peak, end_step=2000):\n    return (peak / 2) * (1 - math.cos((2 * math.pi * step) / end_step))\n\ndp.add_demand_function((\"edge1\", \"edge10\"), (0, 2000), cos, {\"peak\": 2200}, vehicle_types=\"cars\")\ndp.plot_demand()\n</code></pre> <p></p>"},{"location":"4_demand/#removing-demand","title":"Removing Demand","text":"<p>Demand can be removed from a profile using the <code>DemandProfile.remove_demand()</code> function. This will remove all demand in the profile in a specific time range, defined in seconds. An example of this is shown below.</p> <pre><code>def cos(step, peak, end_step=2000):\n    return (peak / 2) * (1 - math.cos((2 * math.pi * step) / end_step))\n\ndp.add_demand_function((\"edge1\", \"edge10\"), (0, 2000), cos, {\"peak\": 2200}, vehicle_types=\"cars\")\n\n# Remove all demand from the profile betwen 500-1000 seconds\ndp.remove_demand(500, 1000)\ndp.plot_demand()\n</code></pre> <p></p>"},{"location":"4_demand/#saving-loading-profiles","title":"Saving &amp; Loading Profiles","text":"<p>Demand profiles can either be saved individually using <code>DemandProfile.save()</code>, which will save the profile as a serialised '.pkl' file, or using <code>Simulation.save_objects()</code>, which will save the profile alongside other objects (such as controllers). An example of this is shown below.</p> <pre><code># Load demand from a '.csv' file\ndp.load_demand(\"demand.csv\")\n\n# Save to a serialised file\ndp.save(\"demand_profile_1.pkl\")\n\n# Save as part of an objects file\nmy_sim.save_objects(\"all_objects.json\")\n</code></pre> <p>Loading a demand profile is done from a <code>Simulation</code> object using the <code>Simulation.load_demand_profiles()</code> or <code>Simulation.load_objects()</code> functions. If loading an individual profile, ensure the routes are valid for the simulation. Any vehicle types created for the profile will be recreated.</p> <pre><code># Load two demand profiles into the simulation\ndemand_profiles = my_sim.load_demand_profiles([\"demand_profile_1.pkl\", \"demand_profile_2.pkl\"])\ndemand_profiles[0].load_demand(\"peak_demand.pkl\")\n\n# Load objects into the simulation, including any added demand profiles\nmy_sim.load_objects(\"all_objects.json\")\n</code></pre> <p>Alternatively, a <code>DemandProfile</code> object can be converted into a '.rou.xml' file, using the <code>DemandProfile.create_route_file()</code> function. This will save any demand added to the profile as a route file that can be used within SUMO. This can be beneficial as demand defined this way will run much faster than using solely <code>DemandProfile</code> objects.</p> <pre><code>dp.create_route_file(\"demand.rou.xml\")\n\nnew_sim = Simulation(scenario_name=\"example\", scenario_desc=\"Example simulation.\")\nnew_sim.start(\"example_scenario.sumocfg\", route_file=\"demand.rou.xml\")\n</code></pre> <p>Note that data from vehicles added through a <code>DemandProfile</code> will be slightly different to those in a '.rou.xml' due to the way vehicles are inserted. In heavy traffic conditions, average trip times may also be much larger with a <code>DemandProfile</code> object as trip times are calculated using their scheduled entry into the simulation, and does not account for any insertion delay.</p>"},{"location":"4_demand/#vehicle-types","title":"Vehicle Types","text":"<p>Vehicle types can be added to a <code>DemandProfile</code> using the <code>DemandProfile.add_vehicle_type()</code> function. The parameters are the same as in <code>Simulation.add_vehicle_type()</code>, outlined here. Any vehicle types added to a demand profile are saved along with the profile and added to any '.rou.xml' files created from the profile. An example of this is shown below.</p> <pre><code>my_sim = Simulation(scenario_name=\"example\", scenario_desc=\"Example simulation.\")\nmy_sim.start(\"example_scenario.sumocfg\")\n\n# Create a custom white 'vans' vehicle type to the demand profile\ndp.add_vehicle_type(\"vans\", \"delivery\", colour=\"white\", min_gap=0.5)\n\n# Load demand from a '.csv' file\ndp.load_demand(\"demand.csv\")\n\n# Save to a serialised file\ndp.save(\"demand_profile.pkl\")\n\n# Create a '.rou.xml' file, containing 'vans' vehicle type\ndp.create_route_file(\"routes.rou.xml\")\n\n# Create a new/separate simulation object\nnew_sim = Simulation(scenario_name=\"example\", scenario_desc=\"Example simulation.\")\nnew_sim.start(\"example_scenario.sumocfg\")\n\n# Load the profile and 'vans' vehicle type into the new simulation\nnew_dp = new_sim.load_demand_profiles(\"demand_profile.pkl\")\n</code></pre> <p>Once a vehicle type has been added to a demand profile, any other demand profile linked to the same <code>Simulation</code> object can use this same vehicle type. However, these new types are not saved to any of the other profiles.</p>"},{"location":"5_interactions/","title":"Interacting with the Simulation","text":""},{"location":"5_interactions/#testing-values","title":"Testing Values","text":"<p>Several functions exist to check values in the simulation, primarily to check wether objects exist and get their type or status. All of these are within the <code>Simulation</code> class, and are:</p>"},{"location":"5_interactions/#vehicles","title":"Vehicles","text":"Function Return Value <code>vehicle_exists(ID)</code> Whether or not a vehicle with the given ID exists in the simulation. <code>vehicle_loaded(ID)</code> Whether or not a vehicle has been scheduled to enter (or is already in) the simulation. <code>vehicle_to_depart(ID)</code> Whether or not a vehicle has been scheduled to enter (but is not in) the simulation. <code>vehicle_type_exists(ID)</code> Whether or not a vehicle type with the given ID exists. <code>route_exists(ID)</code> Route edges if the ID exists, else returns None."},{"location":"5_interactions/#other-objects","title":"Other Objects","text":"Function Return Value <code>detector_exists(ID)</code> Detector type if the ID exists, else returns None. <code>controller_exists(ID)</code> Whether a controller with the ID exists. <code>event_exists(ID)</code> Event status if the ID exists, else returns None. <code>geometry_exists(ID)</code> Geometry type if ID exists (lane/edge), else returns None. <code>tracked_edge_exists(ID)</code> Whether a tracked edge with the ID exists. <code>junction_exists(ID)</code> Whether a junction with the ID exists. <code>tracked_junction_exists(ID)</code> Whether a tracked junction with the ID exists."},{"location":"5_interactions/#getting-values","title":"Getting Values","text":""},{"location":"5_interactions/#object-ids","title":"Object IDs","text":"<p>The most basic getter functions in the <code>Simulation</code> class return the IDs of objects within the simulation. These are:</p> Function Return Value <code>get_vehicle_ids(vehicle_types)</code> All vehicle IDs, or those of specific type(s). <code>get_detector_ids(detector_types)</code> All detector IDs, or those of specific type(s) - 'multientryexit' or 'inductionloop'. <code>get_controller_ids(controller_types)</code> All controller IDs, or those of specific type(s) - 'VSLController' or 'RGController'. <code>get_event_ids(event_statuses)</code> All event IDs, or those of specific status(es) - 'scheduled', 'active' or 'completed'. <code>get_geometry_ids(geometry_types)</code> All controller IDs, or those of specific type(s) - 'edge' or 'lane'. <code>get_tracked_edge_ids()</code> All tracked edge IDs. <code>get_junction_ids()</code> All junction IDs. <code>get_tracked_junction_ids()</code> All tracked junction IDs."},{"location":"5_interactions/#other-data","title":"Other Data","text":"<p>All data collected throughout the simulation is stored in the <code>sim_data</code> dictionary, however, its data (and other dynamic vehicle data) can be fetched using the <code>Simulation.get_[x]()</code> functions below.</p> <ul> <li><code>get_no_vehicles()</code>:<ul> <li>Returns the number of vehicles in the last step of the simulation.</li> </ul> </li> <li><code>get_no_waiting()</code>:<ul> <li>Returns the number of waiting vehicles in the last step of the simulation.</li> </ul> </li> <li><code>get_tts()</code>:<ul> <li>Returns the Total Time Spent (TTS) by vehicles in the simulation during the last step (in seconds).</li> </ul> </li> <li><code>get_twt()</code>:<ul> <li>Returns the Total Waiting Time (TWT) by vehicles in the simulation during the last step, where waiting vehicles are those with a speed less than 0.1<sup>2</sup> (in seconds).</li> </ul> </li> <li><code>get_to_depart()</code>:<ul> <li>Returns total number of vehicles waiting to enter the simulation during the last step.</li> </ul> </li> <li><code>get_delay()</code>:<ul> <li>Returns total vehicle delay in seconds during the last simulation step (calculated using current vehicle speeds and maximum allowed speed on network lanes).</li> </ul> </li> <li><code>get_interval_network_data(data_keys, n_steps, interval_end, get_avg)</code>:<ul> <li>Returns aggregated, network-wide vehicle data during the time range (<code>curr_step - n_steps - interval_end</code>, <code>curr_step - interval_end</code>). Supported data keys are 'no_vehicles', 'no_waiting', 'tts', 'twt', 'to_depart' and 'delay'.</li> <li>By default, all returned values are totalled over the interval. <code>get_avg</code> denotes whether to return the step average delay instead of the total.</li> <li>If multiple data keys are given, each dataset is returned in a dictionary separated by its key.</li> </ul> </li> <li><code>get_vehicle_data(vehicle_ids)</code>:<ul> <li>Returns a dictionary containing all information on a vehicle. This is; 'type', 'longitude', 'latitude', 'altitude', 'heading', 'speed', 'acceleration', 'stopped', 'length', 'departure', 'destination' and 'origin'.</li> <li>TUD-SUMO stores static information (route origin, vehicle length etc.) to avoid unnecessary repeated calls to TraCI. This is automatically done when calling <code>get_vehicle_data()</code> on a vehicle for the first time.</li> <li><code>vehicle_ids</code> can be a single vehicle ID (string), or a list of IDs (list/tuple). If multiple IDs are given, a dictionary is returned with each vehicle's data stored under its ID.</li> </ul> </li> <li><code>get_all_vehicle_data(vehicle_types, all_dynamic_data):</code><ul> <li>Returns the total number of vehicles in the simulation, the total number of waiting vehicles, and if <code>all_dynamic_data == True</code>, the static &amp; dynamic data for all vehicles.</li> <li>If <code>all_dynamic_data == False</code>, an empty dictionary is returned as the last variable.</li> </ul> </li> <li><code>get_last_step_detector_vehicles(detector_ids, vehicle_types, flatten)</code>:<ul> <li>Returns the IDs of all vehicles who passed over the specified detector(s) in the last simulation step.</li> <li><code>detector_ids</code> and <code>vehicle_types</code> can either be a single value (string) or list of values (list/tuple). If multiple detector IDs are given, IDs for all detectors can either be returned in a single list (<code>flatten = True</code>), or the IDs can be returned in a dictionary with lists of IDs separated by detector (<code>flatten = False</code>).</li> </ul> </li> <li><code>get_last_step_geometry_vehicles(geometry_ids, vehicle_types, flatten)</code>:<ul> <li>Returns the IDs of all vehicles on the specified geometry in the last simulation step.</li> <li><code>geometry_ids</code> and <code>vehicle_types</code> can either be a single value (string) or list of values (list/tuple). If multiple geometry IDs are given, IDs for all geometries can either be returned in a single list (<code>flatten = True</code>), or the IDs can be returned in a dictionary with lists of IDs separated by geometry (<code>flatten = False</code>).</li> </ul> </li> <li><code>get_interval_detector_data(detector_ids, data_keys, n_steps, interval_end, avg_step_vals, avg_det_vals, sum_counts)</code>:<ul> <li>Returns data collected by one detector or multiple detectors during the time range (<code>curr_step - n_steps - interval_end</code>, <code>curr_step - interval_end</code>).</li> <li>If multiple detector IDs are given, data is returned in a dictionary separated by detector (and data keys). If <code>avg_det_vals == True</code>, data is averaged (step-wise) for all detectors (ie. <code>{\"det_1\": [1, 2, 3], \"det_2\": [3, 2, 1]}</code> is averaged to <code>[2, 2, 2]</code>).</li> <li>If <code>avg_step_vals == True</code>, data is averaged across all steps (ie. <code>{\"det_1\": [1, 2, 3], \"det_2\": [3, 2, 1]}</code> is averaged to <code>{\"det_1\": 2, \"det_2\": 2}</code>).</li> <li>If multiple detector IDs are given and <code>avg_step_vals == avg_det_vals == True</code>, a single averaged value is returned (for all data keys) (ie. <code>{\"det_1\": [1, 2, 3], \"det_2\": [3, 2, 1]}</code> is averaged to <code>2</code>).</li> <li><code>data_keys</code> can either be a single value (string) or a list of values (list/tuple). The valid keys are 'no_vehicles', 'no_unique_vehicles', 'flow', 'density', 'speeds' and 'occupancies', although 'occupancies' is only valid for induction loop detectors.</li> <li>'no_vehicles' returns the vehicle counts by the detector at each step, meaning vehicles may be counted multiple times across different steps. 'no_unique_vehicles' instead returns the number of unique vehicles that passed over the detector during the specified interval, which is generally much lower than raw vehicle counts.</li> <li>'flow' and 'density' always return the averaged value, instead of values for each step in the interval. These are calculated using the number of unique vehicles and average speeds.</li> <li>If multiple data keys are given, each dataset is returned in a dictionary separated by its key (and detectors), such as <code>{\"det_1\": {\"speeds\": ..., \"flows\": ...}, \"det_2\": ...}</code>.</li> <li><code>sum_counts</code> denotes whether to return the sum of vehicle counts ('no_vehicles' and 'no_unique_vehicles') throughout the interval instead of their average values. <code>sum_counts</code> will override <code>avg_step_vals</code>.</li> </ul> </li> </ul> <p>To query routes and paths in the network, use the functions below.</p> <ul> <li><code>is_valid_path(edge_ids)</code>:<ul> <li>Tests whether a list of edges is a valid path. This is determined by checking whether each edge connects to the subsequent edge in the list.</li> <li>Valid paths can be added as a route using the <code>Simulation.add_route()</code> function.</li> </ul> </li> <li><code>get_path_travel_time(edge_ids, curr_tt, unit)</code>:<ul> <li>Calculate the travel time of a path (list of edges). If <code>curr_tt</code> is true, the travel time is calculated using current mean speed on edges. If <code>curr_tt</code> is false, the travel time is calculated using free-flow speed.</li> </ul> </li> <li><code>get_path_edges(origin, destination, curr_optimal)</code>:<ul> <li>Uses the A* algorithm to find the optimal route between two edges (<code>origin</code> to <code>destination</code>).</li> <li>If <code>curr_optimal</code> is true, the route is based on current conditions, using current mean speed on edges to find travel time. If <code>curr_optimal</code> is false, the route is calculated based on free-flow travel time.</li> </ul> </li> </ul>"},{"location":"5_interactions/#advanced-getters","title":"Advanced Getters","text":"<p>Vehicles, detectors and geometries all use a <code>Simulation.get_[x]_vals()</code> function, which allow you to very easily get a set of values for multiple objects. All 3 use the same structure, with the same type of parameters:</p> <ol> <li><code>vehicle_ids</code>/<code>detector_ids</code>/<code>geometry_ids</code>: A single ID (string) or list of IDs (list/tuple)</li> <li><code>data_keys</code>: A single data key (string) or list of data keys (list/tuple)</li> </ol> <p>If one data key is given, the raw value is returned, otherwise, a dictionary is returned containing the values separated by data key. Similarly, if one object ID is given, the raw data value/dictionary is returned, otherwise, a dictionary is returned containing the data separated by vehicle ID. For example:</p> <pre><code>&gt;&gt;&gt; my_sim.get_vehicle_vals(\"vehicle_1\", \"speed\")\n25\n\n&gt;&gt;&gt;  my_sim.get_vehicle_vals(\"vehicle_1\", (\"speed\", \"acceleration\"))\n{\"speed\": 25, \"acceleration\": -1}\n\n&gt;&gt;&gt;  my_sim.get_vehicle_vals((\"vehicle_1\", \"vehicle_2\"), \"speed\")\n{\"vehicle_1\": 25, \"vehicle_2\": 30}\n\n&gt;&gt;&gt;  my_sim.get_vehicle_vals((\"vehicle_1\", \"vehicle_2\"), (\"speed\", \"acceleration\"))\n{\"vehicle_1\": {\"speed\": 25, \"acceleration\": -1}, \"vehicle_2\": {\"speed\": 30, \"acceleration\": 2}}\n</code></pre> <p>Subscriptions and static vehicle data are used whenever possible to reduce TraCI calls. The valid data keys for each function are listed below.</p> <ul> <li><code>get_vehicle_vals()</code>:<ul> <li>'type': Vehicle type</li> <li>'length': Vehicle length</li> <li>'speed': Current vehicle speed</li> <li>'is_stopped': Bool denoting whether the vehicle is stopped</li> <li>'max_speed': Vehicle maximum speed</li> <li>'acceleration': Current vehicle acceleration</li> <li>'position': Current vehicle coordinates</li> <li>'altitude': Current vehicle altitude</li> <li>'heading': Current vehicle heading</li> <li>'departure': Vehicle departure time</li> <li>'edge_id': Current vehicle's edge ID</li> <li>'lane_id': Current vehicle's lane ID</li> <li>'lane_idx': Index of the vehicle's current lane</li> <li>'origin': Departure edge ID of the vehicle</li> <li>'destination': Current destination edge ID of the vehicle</li> <li>'route_id': Current vehicle route ID</li> <li>'route_idx': The index of the vehicle's edge on its route</li> <li>'route_edges': The list of edges that the vehicle's route consists of</li> <li>'allowed_speed': Current vehicle's maximum allowed speed, based on its location &amp; type</li> <li>'leader_id': Returns the ID of the leading vehicle (returns <code>None</code> if no leading vehicle within 100m)</li> <li>'leader_dist': Returns the distance to the leading vehicle (returns <code>None</code> if no leading vehicle within 100m)</li> </ul> </li> <li><code>get_detector_vals()</code>:<ul> <li>'type': Detector type ('mutlientryexit' or 'inductionloop')</li> <li>'position': Detector coordinates</li> <li>'vehicle_count': Number of vehicles that passed over the detector in the last step</li> <li>'vehicle_ids': IDs of vehicles that passed over the detector in the last step</li> <li>'lsm_speed': Average speed of vehicles that passed over the detector in the last step</li> <li>'halting_no': Number of halting vehicles in the detector area (multi-entry-exit only)</li> <li>'lsm_occupancy': Average occupancy during the last step (induction loop only)</li> <li>'last_detection': Time since last detection (induction loop only)</li> <li>'avg_vehicle_length': Average length of vehicles that passed over the detector in the last step (induction loop only)</li> </ul> </li> <li><code>get_geometry_vals()</code>:<ul> <li>'vehicle_count': Number of vehicles on the edge/lane</li> <li>'vehicle_ids': IDs of vehicles on the edge/lane</li> <li>'vehicle_speed': Average speed of vehicles on the edge/lane</li> <li>'avg_vehicle_length': Average length of vehicles on the edge/lane in the last step.</li> <li>'halting_no': Number of halting vehicles on the edge/lane</li> <li>'vehicle_occupancy': Vehicle occupancy of edge/lane</li> <li>'curr_travel_time': Estimated travel time (calculated using length and average speed)</li> <li>'ff_travel_time': Estimated free-flow travel time (calculated using length and maximum speed)</li> <li>'emissions': CO, CO<sub>2</sub>, HC, PMx and NOx emissions, stored in a dictionary</li> <li>'length': Length of the edge/lane</li> <li>'max_speed': Maxmimum speed (edge max_speed is the average of its lanes)</li> <li>'connected_edges': Dictionary containing 'incoming' and 'outgoing' edges (edge only)</li> <li>'incoming_edges': Incoming edges (edge only)</li> <li>'outgoing_edges': Outgoing edges (edge only)</li> <li>'street_name': Street name, defined in SUMO (edge only)</li> <li>'n_lanes': Number of lanes in the edge (edge only)</li> <li>'lane_ids': IDs of all lanes in the egde (edge only)</li> <li>'edge_id': Edge ID for the lane (lane only)</li> <li>'n_links': Number of linked lanes (lane only)</li> <li>'allowed': List containing allowed vehicle types (lane only)</li> <li>'disallowed': List containing all prohibited vehicle types (lane only)</li> <li>'left_lc': Bool denoting whether left lane changes are allowed (lane only)</li> <li>'right_lc': Bool denoting whether right lane changes are allowed (lane only)</li> </ul> </li> </ul>"},{"location":"5_interactions/#setting-values","title":"Setting Values","text":"<p>Both vehicle and geometries (edges/lanes) also allow for dynamically setting variables with the <code>Simulation.set_vehicle_vals()</code> and <code>Simulation.set_geometry_vals()</code> functions. Both use the same types of parameters:</p> <ol> <li><code>vehicle_ids</code>/<code>geometry_ids</code>: A single ID (string) or list of IDs (list/tuple). If multiple IDs are given, the values are set for all objects.</li> <li><code>data_keys</code>: Unlike the <code>get_[x]_vals()</code> functions, data_keys are used as arguments. There is no limit on the number of data keys given.</li> </ol> <p>For example:</p> <pre><code>&gt;&gt;&gt; my_sim.set_geometry_vals(\"edge_1\", max_speed=40)\n&gt;&gt;&gt; my_sim.set_vehicle_vals((\"vehicle_1\", \"vehicle_2\"), max_speed=20, highlight=\"#FF0000\")\n</code></pre> <p>The valid data keys and their accepted data type are listed below. Note that the keys aim to be the same as those in the <code>get_[x]_vals()</code> functions (whenever possible).</p> <ul> <li><code>set_vehicle_vals()</code>:<ul> <li><code>type</code>: Changes the vehicle's type to another pre-existing type (string)</li> <li><code>colour</code>: Changes the vehicle's colour (either valid hex code or list of rgb(a) values)</li> <li><code>highlight</code>: Sets vehicle highlighting (boolean)</li> <li><code>speed</code>: Sets a new speed value for the vehicle (integer or float)</li> <li><code>max_speed</code>: Sets a new maximum speed for the vehicle (integer or float)</li> <li><code>acceleration</code>: Sets a new acceleration for a given duration (list/tuple containing speed value and duration)</li> <li><code>lane_idx</code>: Sets a vehicle to try and change lane index for a given duration (list/tuple containing lane index and duration)</li> <li><code>destination</code>: Sets a new destination by edge ID (string)</li> <li><code>route_id</code>: Sets the vehicle to another route by its ID (string)</li> <li><code>route_edges</code>: Sets the vehicle to a new route by edge IDs (list of strings)</li> <li><code>speed_safety_checks</code>: Indefinitely sets whether speed/acceleration safety constraints are followed when setting speed - can be boolean to turn on/off all checks or bitset (boolean/int)</li> <li><code>lc_safety_checks</code>: Indefinitely sets whether lane changing safety constraints are followed when changing lane - can be boolean to turn on/off all checks or bitset (boolean/int)</li> </ul> </li> <li><code>set_geometry_vals()</code>:<ul> <li><code>max_speed</code>: Set a new maximum speed/speed limit (lane or for all contained lanes) (integer or float)</li> <li><code>allowed</code>: Set a new list of allowed vehicle types, with an empty list allowing all (list of strings) (lane only)</li> <li><code>disallowed</code>: Set a new list of prohibited vehicle types (list of strings) (lane only)</li> <li><code>left_lc</code>: Sets the list of vehicle types that are allowed to change to the left lane (list of strings) (lane only)</li> <li><code>right_lc</code>: Sets the list of vehicle types that are allowed to change to the right lane (list of strings) (lane only)</li> </ul> </li> </ul>"},{"location":"5_interactions/#subscriptions","title":"Subscriptions","text":"<p>Subscriptions are a useful tool in TraCI that aim to reduce runtime by limiting the amount of API calls. This can be particularly effective when data needs to be collected at each simulation step. TUD-SUMO automatically adds vehicle subscriptions for basic variables including position, speed and acceleration as these are already used within the automatic data collection and are necessary for calculating vehicle delay at each step. Tracked edges will also automatically subcribe to vehicle IDs, as this is needed to collect step vehicle data.</p> <p>It is possible to disable automatic vehicle subscriptions by setting <code>automatic_subscriptions = False</code> in <code>Simulation.start()</code>. However, this is most likely unncessary and not recommened, particularly for applications where a lot of data needs to be repeatedly collected from the simulation.</p> <p>Otherwise, depending on the use case, it may be necessary to subscribe/unsubscribe to other variables. This can be done using the functions below. These use the same structure as the <code>get_[x]_vals()</code> functions with two parameters:</p> <ol> <li><code>vehicle_ids</code>/<code>detector_ids</code>/<code>geometry_ids</code>: A single ID (string) or list of IDs (list/tuple). Note that individual objects have their own set of subscriptions.</li> <li><code>data_key</code>: A single data key (string) or list of data keys (list/tuple).</li> </ol> <p>The valid data keys for each object type and respective function are listed below. Note that individual objects have their own set of subscriptions, so if you would like to subscribe to collect all vehicles' edge ID at each step, you must call <code>add_vehicle_subscriptions()</code> for all vehicle IDs.</p> <ul> <li> <p><code>add_vehicle_subscriptions()</code>/<code>remove_vehicle_subscriptions()</code>:</p> <ul> <li>'speed'</li> <li>'is_stopped'</li> <li>'max_speed'</li> <li>'acceleration'</li> <li>'position'</li> <li>'altitude'</li> <li>'heading'</li> <li>'edge_id'</li> <li>'lane_idx'</li> <li>'route_id'</li> <li>'route_idx'</li> </ul> </li> <li> <p><code>add_detector_subscriptions()</code>/<code>remove_detector_subscriptions()</code>:</p> <ul> <li>'vehicle_count'</li> <li>'vehicle_ids'</li> <li>'lsm_speed'</li> <li>'halting_no'</li> <li>'lsm_speed'</li> <li>'last_detection'</li> </ul> </li> <li> <p><code>add_geometry_subscriptions()</code>/<code>remove_geometry_subscriptions()</code>:</p> <ul> <li>'vehicle_count'</li> <li>'vehicle_ids'</li> <li>'vehicle_speed'</li> <li>'halting_no'</li> <li>'occupancy'</li> </ul> </li> </ul>"},{"location":"5_interactions/#addingremoving-vehicles","title":"Adding/removing Vehicles","text":"<p>Vehicles can be added to or removed from the simulation using the <code>Simulation.add_vehicle()</code> and <code>Simulation.remove_vehicles()</code> functions respectively. These functions and their parameters are detailed below.</p> <ul> <li><code>add_vehicle()</code>:<ul> <li><code>vehicle_id</code>: (Unique) ID for the new vehicle.</li> <li><code>vehicle_type</code>: Vehicle type.</li> <li><code>routing</code>: Denotes how the vehicle will route through the network (either route ID or (2x1) list of edge IDs for an OD pair).</li> <li><code>initial_speed</code>: Initial speed of the vehicle at insertion, defaults to maximum (either 'max', 'random' or a number &gt; 0).</li> <li><code>origin_lane</code>: Lane for insertion at origin, defaults to best (either 'random', 'free', 'allowed', 'best', 'first' or lane index).</li> </ul> </li> <li><code>remove_vehicles()</code>:<ul> <li><code>vehicle_ids</code>: A single vehicle ID (string) or list of IDs (list/tuple).</li> </ul> </li> </ul> <p>Warning</p> <p>Removing vehicles causes a SUMO error to be printed to the console, an example of which is shown below. This has no impacts on the simulation and can be safely ignored. </p> <pre><code>Error: Answered with error to command 0xa4: Vehicle 'vehicle_0' is not known.\nError! Vehicle 'vehicle_0' is not known.\n</code></pre> <p>When repeatedly adding new vehicles, it may be useful to create a new route that vehicles can be assigned to. This can be done using <code>Simulation.add_route()</code>, which is detailed below.</p> <ul> <li><code>add_route()</code>:<ul> <li><code>routing</code>: List of edge IDs. If 2 disconnected edges are given, vehicles calculate an optimal path at insertion.</li> <li><code>route_id</code>: (Unique) route ID. If this is not given, the ID is generated using the origin and destination edge IDs.</li> <li><code>assert_new_id</code>: If true, an error is thrown for duplicate route IDs.</li> </ul> </li> </ul>"},{"location":"5_interactions/#custom-vehicle-types","title":"Custom Vehicle Types","text":"<p>Instead of solely using vehicle types defined in netedit and '.rou.xml' files, new vehicle types can be created dynamically using the <code>Simulation.add_vehicle_type()</code> function. Its parameters are shown below, with more information in the SUMO documentation.</p> <ul> <li><code>vehicle_type_id</code>: ID for the new vehicle type.</li> <li><code>vehicle_class</code>: Vehicle class (defaults to passenger).</li> <li><code>colour</code>: Vehicle type colour, either hex code, list of rgb/rgba values or valid SUMO colour string.</li> <li><code>length</code>: Length of vehicle in metres/feet.</li> <li><code>width</code>: Width of vehicle in metres/feet.</li> <li><code>height</code>: Height of vehicle in metres/feet.</li> <li><code>mass</code>: Mass of vehicle in kilograms.</li> <li><code>speed_factor</code>: Vehicle type multiplier for lane speed limits.</li> <li><code>speed_dev</code>: Vehicle type deviation of the speed factor.</li> <li><code>min_gap</code>: Minimum gap after leader (m).</li> <li><code>acceleration</code>: Vehicle type acceleration ability (m/s<sup>2</sup>).</li> <li><code>deceleration</code>: Vehicle type deceleration ability (m/s<sup>2</sup>).</li> <li><code>tau</code>: Car following model parameter.</li> <li><code>max_lateral_speed</code>: Maximum lateral speed (m/s).</li> <li><code>gui_shape</code>: Vehicle shape in GUI (defaults to vehicle class name).</li> </ul> <pre><code># Add a custom green 'cars' vehicle type with faster acceleration of 3m/s^2\nmy_sim.add_vehicle_type(\"cars\", colour=\"green\", acceleration=3.0)\n\n# Add a custom white 'vans' vehicle type with a short minimum gap of 0.5m\nmy_sim.add_vehicle_type(\"vans\", \"delivery\", colour=\"white\", min_gap=0.5)\n</code></pre>"},{"location":"5_interactions/#custom-vehicle-functions","title":"Custom Vehicle Functions","text":"<p><code>Simulation.add_vehicle_in_functions()</code> and <code>Simulation.add_vehicle_out_functions()</code> can be used to easily add custom functions that are called with each vehicle that enters or leaves the simulation. An example of this is shown below. Multiple functions can be added and are called in the order in which they are added.</p> <p>If certain parameters are included, their values will be automatically generated with each vehicle. These are:</p> <ul> <li><code>simulation</code>: The simulation object itself.</li> <li><code>curr_step</code>: The current simulation step.</li> <li><code>vehicle_id</code>: Each vehicle ID.</li> <li><code>route_id</code>: Route the vehicle will travel on.</li> <li><code>vehicle_type</code>: Vehicle type ID.</li> <li><code>departure</code>: Departure time of the vehicle.</li> <li><code>origin</code>: Origin egde ID of the vehicle.</li> <li><code>destination</code>: Destination edge ID of the vehicle.</li> </ul> <pre><code>def recolour_vehicle(simulation, vehicle_id, new_colour=\"#FF0000\"):\n    simulation.set_vehicle_vals(vehicle_id, colour=new_colour)\n\nnew_vehicles = []\ndef register_vehicle(vehicle_id, curr_step, arr):\n    print(vehicle_id, \"entered simulation at step\", curr_step)\n    arr.append(vehicle_id)\n\ndef exit_vehicle(vehicle_id, curr_step):\n    print(vehicle_id, \"left simulation at step\", curr_step)\n\nmy_sim.add_vehicle_in_functions(functions=[recolour_vehicle, register_vehicle],\n                                parameters={\"register_vehicle\": {\"arr\": new_vehicles}})\nmy_sim.add_vehicle_out_functions(exit_vehicle)\n\nwhile my_sim.is_running():\n    my_sim.step_through()\n</code></pre> <p>Running this example would print the message below to the console. The <code>arr</code> list would also contain <code>['car_1', 'car_2', 'car_3']</code>.</p> <pre><code>&gt;&gt;&gt; run_sim.py\ncar_1 entered simulation at step 0\ncar_2 entered simulation at step 2\ncar_3 entered simulation at step 4\ncar_1 left simulation at step 10\ncar_2 left simulation at step 12\ncar_2 left simulation at step 14\n</code></pre> <p>Only <code>simulation</code>, <code>curr_step</code> and <code>vehicle_id</code> can be used for both vehicle in and out functions. Trip-related variables cannot be used in vehicle out functions. Extra parameters can be used by passing in a parameters dictionary as below. These can later be updated using <code>Simulation.update_vehicle_function_parameters()</code>. Note that it is not necessary to include a <code>new_colour</code> parameter in the dictionary, as this already has a default value.</p> <p>These functions can be removed using <code>Simulation.remove_vehicle_in_functions()</code> and <code>Simulation.remove_vehicle_out_functions()</code>.</p>"},{"location":"6_tracked_objs/","title":"Tracked Objects","text":"<p>Tracked objects are a useful way to include extra objects in the automatic data collection. Whilst all data from every detector is automatically included, specific scenarios may contain a large number of edges or junctions. Therefore, important edges or junctions can be tracked to automatically collect more specific information, such as inflow or average speeds. Tracked objects are also supported within the plotter class, so that phase signal diagrams or space-time diagrams can easily be plotted with significantly less effort.</p> <p>Currently, only edges and junctions can be tracked, although this may change in the future.</p>"},{"location":"6_tracked_objs/#tracked-junctions","title":"Tracked Junctions","text":"<p>There are two types of tracked junctions; regular junctions and metered junctions. Most intersections will only need to be tracked as a regular junction, whilst metered junctions are a subclass of junction that include some extra tracking for motorway on-ramp metering.</p> <p>Tip</p> <p>Note that traffic light/ramp meter control itself is not discussed here. An adaptive traffic signal or ramp meter does not have to be tracked and not all tracked junctions require some control. Tracking a junction with an adaptive traffic signal or ramp meter simply adds a level of data collection, however, it is recommended and makes evaluation of the controllers much easier.</p> <p>All parameters to create a tracked junction are given as a dictionary and is done using the <code>Simulation.add_tracked_junctions()</code> function. This can be in code, or from a '.json' or '.pkl' file. Tracked junctions can also be included in the object parameters file when calling <code>Simulation.load_objects()</code>, under 'junctions'. A tracked junction can be initialised at 3 different levels, depending on the amount of data collection required.</p> <ol> <li> <p>Signal tracking only:</p> <ul> <li>This is the lowest level of tracking, where only signal phases and average green/red times are tracked. Therefore, this level is only useful when the specified junction has a traffic light.</li> <li>In this case, the only required parameters are the junction ID or a list of junction IDs. It is recommended to give junctions and their traffic lights the same ID in SUMO in order to avoid confusion.</li> </ul> </li> <li> <p>Inflow/outflow tracking:</p> <ul> <li>Traffic-flow related variables can be tracked by tracked junctions, however, it is necessary to define the detectors used to do so.</li> <li>Here, the input for <code>Simulation.add_tracked_junctions()</code> is a dictionary, where each junction has a 'flow_params' value. This is a dictionary containing 'inflow_detectors', 'outflow_detectors' and 'vehicle_types'. 'inflow_detectors' and 'outflow_detectors' are lists containing the detectors that will be used to register vehicles entering and exiting the junction, whilst 'vehicle_types' is an optional parameter that lists the vehicle types that should be registered (defaults to all).</li> </ul> </li> <li> <p>Metered junctions:</p> <ul> <li>Metered junctions adds options for tracking queuing variables; queue length, queue delay and spillback. This is primarily designed for use in ramp metering systems.</li> <li>Here, the input for <code>Simulation.add_tracked_junctions()</code> is a dictionary, where each junction has a 'meter_params' value. This is a dictionary containing 'min_rate', 'max_rate', 'init_rate', 'queue_detector' and 'ramp_edges'. These are detailed below, however, flow can still be tracked as above.</li> <li>'min_rate' is a required parameter denoting the minimum allowed metering rate.</li> <li>'max_rate' is a required parameter denoting the maximum allowed metering rate.</li> <li>'init_rate' denotes the initial metering rate set after initialisation.</li> <li>'queue_detector' is the ID of a multi-entry-exit detector that should be placed on the on-ramp. The entry detector should be placed at the start of the on-ramp, and the exit detector just before the traffic light. If given, queue length and delay at each step is tracked automatically.</li> <li>If you would like to track vehicle spillback, provide the list of edge IDs that make up the ramp under the 'ramp_edges' parameter. This can also be used instead of 'queue_detector' to track queue length and delay, however, this approach is much slower. Tracking spillback in this way will only work when vehicles are inserted directly onto the on-ramp (ie. no urban roads connect to the on-ramp), and requires checking all unloaded vehicles of their insertion edge which can be slow.</li> </ul> </li> </ol> <p>Examples of these different levels are shown below.</p> <pre><code># Level 1: Only signal phases &amp; green/red times are tracked\nmy_sim.add_tracked_junctions([\"traffic_signal_1\", \"traffic_signal_2\"])\n\n# Level 2: Track inflow/outflow (&amp; signal phases &amp; green/red times)\nmy_sim.add_tracked_junctions({\"traffic_signal_3\":\n                                {\"flow_params\":\n                                    {\"inflow_detectors\":  [\"det_in_1\", \"det_in_2\"],\n                                     \"outflow_detectors\": [\"det_out_1\", \"det_out_2\"],\n                                     \"vehicle_types\": [\"cars\", \"lorries\", \"motorcycles\", \"vans\"]}\n                                }\n                            })\n\n# Level 3: Track metering (&amp; inflow/outflow &amp; signal phases &amp; green/red times)\nmy_sim.add_tracked_junctions({\"ramp_meter\":\n                                {\"meter_params\":\n                                    {\"min_rate\": 200,\n                                    \"max_rate\": 2000,\n                                    \"queue_detector\": \"ramp_queue\"},\n                                \"flow_params\":\n                                    {\"inflow_detectors\": [\"ramp_inflow\", \"ramp_upstream\"],\n                                    \"outflow_detectors\": [\"ramp_downstream\"]}\n                                }\n                            })\n</code></pre> <p>All data from tracked junctions is stored in the <code>sim_data</code> dictionary under 'data/junctions/{junction_id}'. This will contain the junction's 'position', 'incoming_edges', 'outgoing_edges', 'init_time' and 'curr_time' (referring to the start and end time of the data collection). Phase data is then stored under 'tl', whilst flow and metering data are under 'flow' and 'meter' respectively.</p> <p>Data collection for tracked junctions can be reset using the function below, however, data collection is also reset when using <code>Simulation.reset_data()</code>.</p> <pre><code>my_sim.tracked_junctions[\"traffic_signal_1\"].reset()\n</code></pre>"},{"location":"6_tracked_objs/#tracked-edges","title":"Tracked Edges","text":"<p>Tracked edges are very simple to initialise, but include a lot of useful data collection. Edges are tracked using only their ID with the <code>Simulation.add_tracked_edges()</code> function.</p> <pre><code># Add all edges as a tracked edge\nmy_sim.add_tracked_edges()\n\n# Add a list of edges as tracked edges\nmy_sim.add_tracked_edges([\"edge_1\", \"edge_2\", \"edge_3\", \"edge_4\", \"edge_5\"])\n</code></pre> <p>All data from tracked edges is stored in the <code>sim_data</code> dictionary under 'data/edges/{edge_id}'. The main data collected is under 'data/edges/{edge_id}/step_vehicles'. This includes the vehicle ID, position, speed and lane index for all vehicles on the edge at each step. This precise data is used to plot trajectories and space-time diagrams.</p> <p>The step vehicle data is stored in a (4x1) array as follows:</p> <ol> <li>Vehicle ID</li> <li>Vehicle position measured as [0 - 1], denoting percent travelled along the edge</li> <li>Vehicle speed in <code>Simulation</code> class units</li> <li>Lane index [0 - no. lanes]</li> </ol> <p>Tracked edges collect average speed, flow and density at each time step and store these values in a list. Funamental diagrams can be plotted with <code>TrackedEdge</code> data using the <code>Plotter.plot_fundamental_diagram()</code> function, but it is possible to return the individual values. This data is stored in the <code>sim_data</code> dictionary under 'data/edges/{edge_id}/speeds', 'data/edges/{edge_id}/flows' and 'data/edges/{edge_id}/densities', but can be fetched from the <code>TrackedEdge</code> object as below. A value of -1 denotes that there were no vehicles on the edge during the step. Time occupancy is also collected and stored under 'data/edges/{edge_id}/occupancies'.</p> <pre><code>speeds    = my_sim.tracked_edges[\"edge_1\"].speeds\nflows     = my_sim.tracked_edges[\"edge_1\"].flows\ndensities = my_sim.tracked_edges[\"edge_1\"].densities\n</code></pre> <p>'linestring', 'length', 'to_node', 'from_node', 'n_lanes', 'init_time' and 'curr_time' are also stored for each edge.</p> <p>Data collection for specific tracked edges can be reset using the function below, however, data collection is also reset when using <code>Simulation.reset_data()</code>.</p> <pre><code>my_sim.tracked_edges[\"edge_1\"].reset()\n</code></pre>"},{"location":"7_traffic_control/","title":"Traffic Control","text":""},{"location":"7_traffic_control/#traffic-signal-control","title":"Traffic Signal Control","text":"<p>Tip</p> <p>No initialisation is needed to perform dynamic traffic signal control, however, it is recommeded to create a tracked junction to automatically collect data from the junction.</p> <p>By default, all traffic signals will use the phases set in SUMO/netedit at the beginning of the simulation. TUD-SUMO is able to override these settings and update phases automatically, which is done using a <code>phase_dict</code> as shown below. A <code>phase_dict</code> can be included in the parameters file under 'phases' when calling <code>Simulation.load_objects()</code>.</p> <pre><code>phase_dict = {\"traffic_signal_1\":\n                 {\"phases\": [\"GGrr\", \"yyrr\", \"rrGG\", \"--yy\"],\n                  \"times\": [27, 3, 17, 3]\n                 },\n              \"traffic_signal_2\":\n                 {\"phases\": [\"GGrr\", \"yyrr\", \"rrGG\", \"--yy\"],\n                  \"times\": [20, 3, 34, 3]\n                 }\n             }\n</code></pre> <p>This dictionary uses two components:</p> <ol> <li>Phases:<ul> <li>This contains a list of phase strings, which represent the signal status during each phase. The phase strings must be the same length as the number of movements in SUMO.</li> <li>Characters in the phase string can either 'r' (red), 'y' (yellow), 'g' (green with no priority), 'G' (green with priority) or '-' (do not change).</li> <li>The index of each character refers to the setting for the corresponding movement, which are numbered clockwise starting at north (right turns \u2192 straight \u2192 left turns), with pedestrian crossings at the end.</li> </ul> </li> <li>Times:<ul> <li>This contains the durations in seconds for each corresponding phase string.</li> <li>Phase durations cannot be less than the simulation step length.</li> </ul> </li> </ol> <p>Once this has been created, the phases can be set using the <code>Simulation.set_phases()</code> function. <code>start_phase</code> can be used to start at different points in the phase cycle. <code>overwrite</code> determines whether to completely overwrite the phase dictionary for all signals or simply for specified signals.</p> <pre><code>my_sim.set_phases(phase_dict, start_phase=0, overwrite=True)\n</code></pre> <p>Alternatively, it is possible to set a signal's phases indefinitely using <code>Simulation.set_tl_colour()</code>. The input can either be a regular phase string or a single character, meaning all movements are set this way. <code>Simulation.change_phase()</code> can be used to change to skip to a specific phase in the cycle.</p> <pre><code># Set \"traffic_signal_1\" permanently to all green\nmy_sim.set_tl_colour(\"traffic_signal_1\", \"G\")\n\n# Set \"traffic_signal_2\" permanently to \"rrGG\"\nmy_sim.set_tl_colour(\"traffic_signal_2\", \"rrGG\")\n\n# Skip \"traffic_signal_3\" to phase 3\nmy_sim.change_phase(\"traffic_signal_3\", 2)\n</code></pre>"},{"location":"7_traffic_control/#ramp-metering","title":"Ramp Metering","text":"<p>Ramp metering is a motorway control measure where a traffic light is placed at an on-ramp in order to limit flow and avoid congestion. This help an engineer fully exploit the capacity of a motorway section next to an on-ramp without exceeding it. It is also an important method of reducing the impact of capacity drop, where the measured outflow from a bottleneck is significantly lower than the expected outflow. The most commonly used ramp metering algorithm in practice is Asservissement Lin\u00e9aire d'entr\u00e9e Autoroutiere (ALINEA).</p> <p></p> <p>Tip</p> <p>No initialisation is needed to perform ramp metering, however, it is recommeded to create a tracked junction to automatically collect data from the meter.</p> <p>Like a regular traffic signal, ramp meters will follow the phases defined within SUMO/netedit by default. Otherwise, initialising the ramp meter as a tracked junction will allow you to set an initial metering rate, which will start at the next simulation step.</p> <pre><code>my_sim.add_tracked_junctions({\"ramp_meter\":\n                                {'meter_params':\n                                    {'min_rate': 200,  # Minimum allowed metering rate\n                                    'max_rate': 2000,  # Maximum allowed metering rate\n                                    'init_rate': 1800, # Initial metering rate\n                                    'queue_detector': \"ramp_queue\"},\n                                'flow_params':\n                                    {'inflow_detectors': [\"ramp_inflow\", \"ramp_upstream\"],\n                                    'outflow_detectors': [\"ramp_downstream\"]}\n                                }\n                            })\n</code></pre> <p>The ramp metering rate can then be set as below. Note that all metering rates are defined in vehicles/hour.</p> <pre><code>my_sim.set_tl_metering_rate(rm_id=\"ramp_meter\", metering_rate=1500)\n</code></pre> <p>Ramp meters use the exact same logic and <code>phase_dict</code> as traffic signals to operate, except the <code>Simulation.set_tl_metering_rate()</code> function calculates a phase setting that would result in the desired flow. This is primarily done by varying the red time. The settings can be changed using the parameters:</p> <ul> <li><code>g_time</code>: Green time, defaults to 1s for a one-car-per-green policy.</li> <li><code>y_time</code>: Yellow time, defaults to 1s.</li> <li><code>min_red</code>: Minimum red time. If the flow would require a red time less than this, the meter is set to green for the duration of the control interval.</li> <li><code>vehs_per_cycle</code>: The number of vehicles released with each cycle. The network will affect how many vehicles pass the meter with each green light, so the phase calculations can be changed to reflect this. By default, <code>vehs_per_cycle</code> is set to the number of lanes on the ramp.</li> <li><code>control_interval</code>: Control interval length in seconds. The cycle of the resulting phases will aim to loop seamlessly (where <code>control_interval % cycle_length == 0</code>), however, this may not be possible to achieve the desired metering rate.</li> </ul> <p>Note that there is a maximum possible flow determined by the green, red and yellow time parameters as well as the infrastructure of the on-ramp itself. For example, with a one lane on-ramp and a <code>g_time</code>, <code>y_time</code> and <code>min_red</code> of 1s, the meter cannot physically release more than 1200 vehicles/hour without reducing the minimum red time. So, when the desired metering rate is above this threshold, the meter is set to green for the whole control interval. This limit is increased as more lanes are added to the on-ramp (as more vehicles are released with each green cycle). Depending on the junction type defined in NETEDIT, some tuning of <code>vehs_per_cycle</code> may be required to reflect the actual amount of vehicles that are released with each cycle. </p> <p>If the junction is tracked, all ramp metering data will be stored under 'data/junctions/{meter_id}/meter', and will contain 'metering_rates', 'rate_times', 'queue_lengths', 'queue_delays', 'min_rate' and 'max_rate'.</p> <p>Warning</p> <p>Note that as ramp meters use the same logic as adaptive traffic signals, it is possible to accidentally overwrite their settings when using <code>Simulation.set_phases()</code>. To avoid this, set <code>overwrite</code> to <code>False</code>.</p>"},{"location":"7_traffic_control/#variable-speed-limits","title":"Variable Speed Limits","text":"<p>Variable Speed Limits (VSL), also called dynamic speed limits, are a method of motorway traffic control where speed limits on road sections are dynamically changed based on conditions. A major advantage of this can be the increased safety, as VSL will often aim to lower and homogenise vehicle speeds, although it can also be used to limit congestion by 'holding back' vehicles and 'storing' them away from congested areas of a network. In practice, VSL is implemented through variable message signs on gantries above the motorway.</p> <p>VSL can be simulated using a <code>VSLController</code> object. These can be added with the <code>Simulation.add_controllers()</code> function with their parameters in a dictionary as below. Multiple VSL and Dynamic Route Guidance (RG) controllers can be created in the same parameter dictionary. This can also be included under 'controllers' when calling <code>Simulation.load_objects()</code>.</p> <pre><code>vsl_parameters = {\"vsl_controller\":\n                     {\"type\": \"VSL\",\n                      \"geometry_ids\": [\"edge_1\", \"edge_2\", \"edge_3\"],\n                      \"default_limit\": 80\n                     }\n                 }\nmy_sim.add_controllers(vsl_parameters)\n</code></pre> <p>Both 'type' and 'geometry_ids' are the only required parameters. 'type' should be set to 'VSL' to create a VSL controller, whilst 'geometry_ids' is a list containing the IDs of edges under control. Note that controlled geometries can be either edges or lanes. 'default_limit' is an optional parameter denoting the default speed limit.</p> <p>A VSL controller can also be created by directly initialising the object with the same parameters dictionary, however, it must be added to the simulation to operate.</p> <pre><code>from tud_sumo.controllers import VSLController\n\nvsl_controller = VSLController(vsl_id=\"vsl_controller\", vsl_params=vsl_parameters, simulation=my_sim)\nmy_sim.add_controllers({\"vsl_controller\": vsl_controller})\n</code></pre> <p>The controller will initialise as deactivated, meaning the controlled edges/lanes will use their default speed limits/maximum speed as defined in SUMO/netedit. However, it can be activated using the <code>VSLController.set_speed_limit()</code> function as below. This can either be used to activate the VSL with a new speed limit value, or to activate the VSL with the previously used speed limit or default value. Note that the same speed limit is set for all controlled edges/lanes.</p> <p>The VSL controller can then be deactivated using the <code>VSLController.deactivate()</code> function. This will set all edges/lanes to their original speed limit as defined in SUMO/netedit.</p> <pre><code># Activate controller, setting speed limit to 60kmph\nmy_sim.controllers[\"vsl_controller\"].set_speed_limit(60)\n\n# Deactivate the control, set speed limits to no-control values\nmy_sim.controllers[\"vsl_controller\"].deactivate()\n\n# Reactivate controller, setting speed limit to last used value (60kmph)\nmy_sim.controllers[\"vsl_controller\"].set_speed_limit()\n</code></pre> <pre><code>&gt;&gt;&gt; my_sim.controllers[\"vsl_controller\"].activated\nTrue\n</code></pre> <p>VSL controllers will automatically register and save the changes in speed limit, and the times at which they occur. This data is stored in the <code>sim_data</code> dictionary under 'data/controllers/{vsl_id}/activation_times'. This stores a series of tuples where the first value is the speed limit setting and the second value is the time step this setting was made. Speed limits of -1 denote the controller is being deactivated. Otherwise, the average speed on controlled edges/lanes throughout the simulation is also collected under 'data/controllers/{vsl_id}/geometry_data/{geometry_id}/avg_speeds'.</p> <p>VSL controller data can be reset using <code>VSLController.reset()</code>, or the controller itself can be removed using <code>Simulation.remove_controllers()</code>.</p>"},{"location":"7_traffic_control/#dynamic-route-guidance","title":"Dynamic Route Guidance","text":"<p>Dynamic Route Guidance (RG) is a method of traffic management where vehicles are rerouted in order to avoid exceeding capacity on certain roads. This can be particularly useful in cases of non-recurrent congestion, such as during an accident, as drivers can be advised to avoid affected roads and given guidance on alternative routes. In practice, this is typically implemented for motorway traffic management with variable message signs above the road, although information can be transmitted directly to drivers with Vehicle-to-Infrastructure (V2I) technology.</p> <p></p> <p>RG can be simulated using a <code>VSLController</code> object. These can be added with the <code>Simulation.add_controllers()</code> function with their parameters in a dictionary as below. Multiple RG and Variable Speed Limit (VSL) controllers can be created in the same parameter dictionary. This can also be included under 'controllers' when calling <code>Simulation.load_objects()</code>.</p> <pre><code>rg_parameters = {\"rg_controller\":\n                    {\"type\": \"RG\",\n                     \"detector_ids\": [\"induction_loop_1\"],\n                     \"old_destination\": \"off_ramp_1\",\n                     \"new_destination\": \"off_ramp_2\",\n                     \"diversion_pct\": 0.5,\n                     \"vehicle_type\": [\"cars\", \"lorries\", \"motorcycles\", \"vans\"],\n                     \"highlight\": \"00FF00\"\n                    }\n                }\nmy_sim.add_controllers(rg_parameters)\n</code></pre> <p>The only required parameters are 'type' and 'detector_ids'. 'type' should be set to 'RG' to create a RG controller, whilst 'detector_ids' is a list containing the IDs of induction loop detectors that will act as the point where vehicles are redirected. All other parameters are optional and are detailed below.</p> <ul> <li>'old_destination': Edge ID. If given, only vehicles with this as their destination will be redirected.</li> <li>'new_destination': Edge ID. If given, this is used as the default new destination for redirected vehicles.</li> <li>'diversion_pct': Float [0-1]. This acts as a probability of redirection for vehicles to simulate compliance. The default is 100%.</li> <li>'vehicle_type': List of vehicle types for redirected vehicles.</li> <li>'highlight': Hex code or list of rgba values. If given, redirected values are recoloured.</li> </ul> <p>A RG controller can also be created by directly initialising the object with the same parameters dictionary, however, it must be added to the simulation to operate.</p> <pre><code>from tud_sumo.controllers import RGController\n\nrg_controller = RGController(vsl_id=\"rg_controller\", rg_params=rg_parameters, simulation=my_sim)\nmy_sim.add_controllers({\"rg_controller\": rg_controller})\n</code></pre> <p>The controller will initialise as deactivated, meaning no vehicles are redirected, however, it can be activated using the <code>RGController.activate()</code> function. Similarly to VSL controllers, this can either be used to activate the RG with a new redirection target or 'new_destination', or to activate the RG with the previously used target or default value. The diversion percent or highlight can also be changed.</p> <pre><code># Activate controller &amp; redirect vehicles to 'off_ramp_2'\nmy_sim.controllers[\"vsl_controller\"].activate(\"off_ramp_2\")\n\n# Deactivate the control &amp; stop redirecting vehicles\nmy_sim.controllers[\"vsl_controller\"].deactivate()\n\n# Reactivate controller &amp; redirect vehicles to 'off_ramp_3\nmy_sim.controllers[\"vsl_controller\"].activate(\"off_ramp_3\")\n</code></pre> <pre><code>&gt;&gt;&gt; my_sim.controllers[\"rg_controller\"].activated\nTrue\n</code></pre> <p>RG controllers will automatically register and save changes, and the times at which they occur. This data is stored in the <code>sim_data</code> dictionary under 'data/controllers/{rg_id}/activation_times'.</p> <p>This stores a series of tuples where the first value is the new destination that vehicles are redirected towards, the second value is the diversion percent and the third is the time this change was made. A destination and diversion percent value of -1 denote the controller is being deactivated. Otherwise, the number of vehicles redirected throughout the simulation is also collected under 'data/controllers/{rg_id}/n_diverted'.</p> <p>New route objects can be created using <code>Simulation.add_route()</code>. Vehicles can then be redirected using the ID for the new route.</p> <p>VSL controller data can be reset using <code>VSLController.reset()</code>, or the controller itself can be removed using <code>Simulation.remove_controllers()</code>.</p>"},{"location":"8_events/","title":"Events","text":"<p>Events can be a useful part of designing a scenario, and can be used to simulate incidents, incident responses, or even different types of fixed control. TUD-SUMO includes the logic to schedule events and undo the changes made, for example, events can be used to reduce the speed limit of a road between specific times. Events designed to simulate incidents can also be created dynamically, with control over where the incident occurs and for how long. Events are also integrated into the plotting functions of TUD-SUMO, and can be displayed automatically on graphs if desired.</p> <p></p>"},{"location":"8_events/#scheduled-events","title":"Scheduled Events","text":"<p>Scheduled events are initialised through a event parameters dictionary, and added to the simulation through the <code>Simulation.add_events()</code> function as below. This dictionary can either be in code or as a '.json' or '.pkl' file, and can be included in the object parameters dictionary under 'events' when calling <code>Simulation.load_objects()</code>. These are shown below.</p> <p>All events require a 'start_time'/'start_step' and 'end_time'/'end_step' which represent when the event will occur, either in steps or simulation time. Otherwise, there are two types of effects that can be used; 'edges' or 'vehicles'.</p> <ol> <li>'edges':<ul> <li>Including edge effects will change edge states when the event is active. Both edges and lanes can be included.</li> <li>Any variable defined in the data keys for the <code>Simulation.set_edge_vals()</code> function can be used. The new edge/lane settings should be included under 'actions' in the edge effects dictionary. The edge/lane IDs should be included under 'edge_ids'.</li> <li>When an event is first scheduled, the base values for all edges/lanes are stored. When the event occurs, all changes defined in the parameters dictionary are made. Once the event is over, all changes are undone.</li> </ul> </li> <li>'vehicles':<ul> <li>Including vehicle effects will aim to change vehicle states whilst the effect is active, or changes can be made indefinitely.</li> <li>Any variable defined in the data keys for the <code>Simulation.set_vehicle_vals()</code> function can be used. The new vehicle settings should be included under 'actions' in the vehicle effects dictionary.</li> <li>Vehicles can either be affected based on a list of vehicle IDs or based on location If 'vehicle_ids', only the specified vehicles will be affected. If 'location' is given, affected vehicles are randomly chosen based on where they are in the network. The locations list can, therefore, include edge IDs, lane IDs or detector IDs, meaning that vehicles that pass over a specific edge/lane/detector can be controlled during an event. It is required to provide either a 'vehicle_ids' or 'location' list.</li> <li>If vehicles are being chosen randomly based on location, there are three other parameters that can be used; 'vehicle_limit', 'effect_probability' and 'effect_duration'. If a 'vehicle_limit' is given, new vehicles will no longer be effected once this threshold has been reached. If an 'effect_probability' is given, new vehicles will only be affected based on this probability. If 'effect_duration' is given, vehicles will only be affected for a certain amount of steps, otherwise, they are permanently affected.</li> <li>The 'highlight' parameter can be used to colour affected vehicles in the GUI.</li> <li>If 'remove_affected_vehicles' is given and when set to <code>True</code>, affected vehicles are removed from the simulation once the effect is over.</li> <li>Both 'speed_safety_checks' and 'lc_safety_checks' are boolean parameters that can be used to disable vehicle safety checks when changing lanes or speed. This may be useful when directing vehicles to make unsafe movements as these checks are enabled in SUMO by default.</li> </ul> </li> </ol> <p>Tip</p> <p>Both vehicle and edge/lane effects can be used during the same scheduled event.</p> <p>An example of a scheduled event with edge effects is shown below. Here, 'lane_1' and 'lane_2' are closed to all vehicles between 200-400s.</p> <pre><code>bn_parameters = {\"bottleneck\": \n                    {\"start_time\": 200,\n                     \"end_time\": 450,\n                     \"edges\":\n                         {\"edge_ids\": [\"lane_1\", \"lane_2\"]\n                          \"actions\":\n                              {\"disallowed\": [\"passenger\",\"trailer\",\"motorcycle\",\"delivery\"]},\n                         }\n                    }\n                }\n</code></pre> <p>Warning</p> <p>When suddenly closing edges or lanes like this, vehicles may get trapped until permissions are changed back. This is expected as closing lanes also closes outgoing connections from the lane, meaning that vehicles cannot leave.</p> <p>An example of a scheduled event with vehicle effects is shown below with a possible reaction to the bottleneck. Here, vehicles on nearby edges 'edge_1', 'edge_2' and 'edge_3' have their maximum speed changed to 40kmph for 100s, with 100% probability. These affected vehicles are coloured red.</p> <pre><code>rp_parameters = {\"bottleneck_reaction\":\n                    {\"start_time\": 210,\n                     \"end_time\": 500,\n                     \"vehicles\":\n                        {\"locations\": [\"edge_1\", \"edge_2\", \"edge_3\"],\n                         \"actions\": {\"max_speed\": 40}\n                         \"effect_duration\": 100,\n                         \"effect_probability\": 1,\n                         \"remove_vehicles\": False,\n                         \"speed_safety_checks\": False,\n                         \"lc_safety_checks\": False,\n                         \"highlight\": \"#FF0000\"\n                        }\n                    }\n                }\n</code></pre> <p>Event parameters are stored in the <code>sim_data</code> dictionary under 'data/events/{status}/{event_id}'. The status can either be 'scheduled', 'active' or 'completed'.</p>"},{"location":"8_events/#dynamic-incidents","title":"Dynamic Incidents","text":"<p>Incidents on the network can be dynamically simulated using the <code>Simulation.cause_incident()</code> function. This creates an event that starts in the next simulation step, where a set of vehicles stop in the road for a set duration. After the incident, these vehicles are removed. Dynamically causing incidents may be useful when training or evaluating incident-responsive traffic management systems.</p> <p>The only required parameter is <code>duration</code>, denoting the duration of the incident in steps. Otherwise, the vehicles chosen can be either specified by the user or completely random. Below is an example of an incident lasting 100s that involves two specific vehicles, 'car_1', 'lorry_1'. By default, the edges that the vehicles are on have their speed limits reduced to 15kmph (or 10mph) to simulate vehicles driving cautiously around the incident. This can be disabled by setting <code>edge_speed</code> to <code>None</code>.</p> <pre><code>my_sim.cause_incident(duration=100, vehicle_ids=[\"car_1\", \"lorry_1\"])\n</code></pre> <p>For random incidents, it is still required to set the location through the <code>geometry_ids</code> parameter. This can be a list of edge/lane IDs or single ID. Vehicles in this location(s) are then randomly selected to be involved in the incident. <code>n_vehicles</code> denotes how many vehicles should be included. <code>vehicle_separation</code> is a float [0-1] that denotes how far apart the randomly selected vehicles should be, with 0 being close. Note that if there not enough vehicles on the selected edges, the surrounding edges are searched, meaning the incident may spread across many distant edges with high <code>vehicle_separation</code>. <code>highlight_vehicles</code> is a boolean that denotes whether to highlight involved vehicles with a circle around them.</p> <p>Warning</p> <p>With a high <code>n_vehicles</code> value, the algorithm may not be able to find enough vehicles, particularly with a high <code>vehicle_separation</code>. If <code>assert_n_vehicles</code> is set to <code>True</code>, an error will be thrown when this is the case, otherwise, the simulation will continue and <code>cause_incidents()</code> will return <code>False</code>.</p> <p>Below is an example of a dynamic incident. Here, 4 cars on edges 'edge_1' and 'edge_2' are stopped on the road for 100s, whilst the edges have their speed reduced to 20kmph. Each incident is added to the simulation as an event, meaning it will show in saved data and on plots as an event. By default, the incident will be defined a unique ID 'incident_[x]', however, an ID can be assigned manually as below.</p> <pre><code>success = my_sim.cause_incident(duration=100,\n                                geometry_ids=[\"edge_1\", \"edge_2\"],\n                                n_vehicles=4,\n                                vehicle_separation=0,\n                                assert_n_vehicles=False,\n                                edge_speed=20,\n                                highlight_vehicles=True,\n                                incident_id=\"pileup\"\n                               )\n</code></pre> <p>Warning</p> <p>At the end of the incident, the vehicles are removed from the simulation which causes a SUMO error to be printed to the console, an example of which is shown below. This has no impacts on the simulation and can be safely ignored. </p> <pre><code>Error: Answered with error to command 0xa4: Vehicle 'vehicle_0' is not known.\nError! Vehicle 'vehicle_0' is not known.\n</code></pre>"},{"location":"9_gui/","title":"GUI &amp; Videos","text":""},{"location":"9_gui/#gui-functions","title":"GUI Functions","text":"<p>Several functions are provided specifically for controlling the Graphical User Interface (GUI). More general information on using the SUMO GUI can be found at sumo.dlr.de/docs/sumo-gui.html. In order to run a simulation with the GUI active using TUD-SUMO, use:</p> <pre><code>from tud_sumo.simulation import Simulation\n\nmy_sim = Simulation(scenario_name=\"example\", scenario_desc=\"Example simulation.\")\nmy_sim.start(\"example_scenario.sumocfg\", gui=True)\n</code></pre> <p>The several functions used for interacting with the SUMO GUI are listed below. The GUI itself can have multiple different views, or windows, but the default/main view is called 'View #0'. Unless new views have been manually added, GUI functions will operate on this default view.</p> <ul> <li><code>set_view()</code>:<ul> <li>Sets a view's bounds and/or zoom level.</li> <li>Bounds use a tuple of two coordinates to define the new view, as in (lower-left point, upper-right point).</li> <li>The zoom level is defined in percent.</li> </ul> </li> <li><code>take_screenshot()</code>:<ul> <li>Takes a screenshot of a view in the next time step and saves the result to a file.</li> <li>If the bounds and/or zoom is not specified, the current view is used.</li> </ul> </li> <li><code>gui_is_tracking()</code>:<ul> <li>Returns whether a specific view is tracking a vehicle.</li> </ul> </li> <li><code>gui_track_vehicle()</code>:<ul> <li>Sets a view to follow a vehicle through the network, either until it leaves the network or the tracking is manually stopped.</li> <li>The vehicle is tracked by its ID, and can be highlighted if <code>highlight</code> is set to <code>True</code>.</li> <li>By default, the main/default view is used. An example of vehicle tracking is shown below.</li> </ul> </li> <li><code>gui_stop_tracking()</code>:<ul> <li>Stops a view from tracking a vehicle.</li> </ul> </li> <li><code>get_gui_views()</code>:<ul> <li>Returns a list of all views added to the GUI.</li> </ul> </li> <li><code>add_gui_view()</code>:<ul> <li>Adds a new GUI view.</li> </ul> </li> <li><code>remove_gui_view()</code>:<ul> <li>Removes a specific GUI view.</li> </ul> </li> <li><code>get_view_boundaries()</code>:<ul> <li>Returns the bounds of a specific view.</li> </ul> </li> <li><code>get_view_zoom()</code>:<ul> <li>Returns the zoom level of a specific view.</li> </ul> </li> </ul> <p></p> <pre><code>while my_sim.curr_step &lt; 500:\n\n    my_sim.step_through()\n\n    if my_sim.curr_step == 100:\n        # Set the default/main view boundaries to (min_x: 0, max_x: 200, min_y: 0, max_y: 200) and zoom to 500%\n        my_sim.set_view(bounds=((0, 0), (200, 200)), zoom=500)\n\n        # Take a screenshot of the current view settings and save it to \"images/screenshot.png\"\n        my_sim.take_screenshot(\"images/screenshot.png\")\n\n    if my_sim.curr_step == 200:\n        # Set the default view/main to follow \"car_0\" as it travels through the network\n        my_sim.gui_track_vehicle(vehicle_id=\"car_0\")\n\n    if my_sim.curr_step == 300:\n        # Set the default view/main to stop following \"car_0\"\n        my_sim.gui_stop_tracking()\n</code></pre>"},{"location":"9_gui/#recording-videos","title":"Recording Videos","text":"<p>The <code>Recorder</code> class can be used to record videos of the GUI through 2 functions; <code>Recorder.record_network()</code> and <code>Recorder.record_vehicle()</code>. Videos are then saved using <code>Recorder.save_recording()</code>. The GUI must be active to record videos.</p> <pre><code>from tud_sumo.videos import Recorder\nfrom tud_sumo.simulation import Simulation\n\nmy_sim = Simulation(scenario_name=\"example\", scenario_desc=\"Example simulation.\")\nmy_sim.start(\"example_scenario.sumocfg\", gui=True)\n\nrecorder = Recorder(my_sim)\n</code></pre> <p>Recordings are defined by a unique recording ID, which allows for multiple recordings to be made at the same time on different views. Videos are made by taking screenshots at each time step, which can then be joined together to create the final video. The frames are saved to a file called <code>{recording_id}_frames</code>, although this can be changed using the <code>frames_loc</code> parameter. The file is always created when the video is started, and is deleted by default, along with the individual frames, once the recording is over.</p> <p>Multiple recordings can be done simultaneously, although they should begin at the same time as each requires a new view to be created. Adding new views changes the aspect ratio of already existing views, which prevents the final video from being created.</p> <p>To record a static recording of a specific part of the network, use <code>Recorder.record_network()</code>. This is based on a <code>bounds</code> and <code>zoom</code> parameter, as shown below. <code>speed</code> can also be changed. By default, videos are real-time when <code>speed = 1</code>, although increasing this value acts as a multiplier on the FPS (<code>FPS = speed / step_length</code>).</p> <pre><code>recording_id = \"network_test\"\n\nwhile my_sim.curr_step &lt; 500:\n\n    my_sim.step_through()\n\n    if my_sim.curr_step == 100:\n        # At t=100, start recording a video with boundaries (min_x: 0, max_x: 200,\n        # min_y: 0, max_y: 200) and zoom 500%. The frames will be saved to a directory\n        # named 'frames' instead of the default 'network_test_frames'\n        recorder.record_network(recording_id = recording_id,\n                                bounds = ((0, 0), (200, 200)), \n                                zoom = 500,\n                                speed = 16,\n                                frames_loc = \"frames\"\n                               )\n</code></pre> <p>To finish the recording and save the final video, use <code>Recorder.save_recording()</code> as below. This will delete the frame files and save the video. By default, the video is called <code>{recording_id}.mp4</code>. Videos can currently be created in an '.mp4', '.avi' or '.gif' format and must be at least 3 time steps long. </p> <pre><code>    if my_sim.curr_step == 300:\n        recorder.save_recording(recording_id, video_filename=\"video.mp4\")\n</code></pre> <p></p> <p>Alternatively, to record a vehicle as it travels through the network, use <code>Recorder.record_vehicle()</code> as below. By default, the recording will finish once the vehicle leaves the network, although it can be ended early using <code>Recorder.save_recording()</code>. The video filename used can be defined at the start of the recording.</p> <pre><code>recording_id = \"vehicle_test\"\n\nwhile my_sim.curr_step &lt; 500:\n\n    my_sim.step_through()\n\n    if my_sim.curr_step == 100:\n        # At t=100, start recording a video of \"car_0\", with zoom 1200%. The\n        # frames will be saved to a directory named 'frames' instead of the\n        # default 'vehicle_test_frames'\n        recorder.record_vehicle(recording_id = recording_id,\n                                video_filename = \"video.avi\",\n                                vehicle_id = \"car_0\", \n                                zoom = 1200,\n                                speed = 20,\n                                frames_loc = \"frames\"\n                               )\n</code></pre> <p></p>"}]}